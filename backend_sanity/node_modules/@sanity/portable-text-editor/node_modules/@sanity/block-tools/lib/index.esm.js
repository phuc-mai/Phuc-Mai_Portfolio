function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
import { uniq, isEqual, flatten } from 'lodash';
import getRandomValues from 'get-random-values-esm';
function isRecord$1(value) {
  return !!value && (typeof value == "object" || typeof value == "function");
}
function isBlock(value) {
  return isRecord$1(value) && typeof value._type === "string" && typeof value.style === "string" && Array.isArray(value.children) && Array.isArray(value.markDefs);
}
function isSpan(value) {
  return isRecord$1(value) && value._type === "span" && typeof value.text === "string" && Array.isArray(value.marks);
}
function isRecord(value) {
  return !!value && (typeof value == "object" || typeof value == "function");
}
function isObjectSchemaType(type) {
  if (!isRecord(type)) return false;
  return type.jsonType === "object";
}
function isArraySchemaType(type) {
  if (!isRecord(type)) return false;
  return type.jsonType === "array";
}
function isTitledListValue(item) {
  return typeof item === "object" && item !== null && "title" in item && "value" in item;
}
function isSpanSchemaType(type) {
  if (!isRecord(type)) return false;
  return Array.isArray(type.annotations) && Array.isArray(type.decorators);
}
function isBlockSchemaType(type) {
  if (!isRecord(type)) return false;
  if (!Array.isArray(type.fields)) return false;
  const [maybeSpanChildren, maybeStyle, maybeList] = type.fields;
  return isBlockChildrenObjectField(maybeSpanChildren) && isStyleObjectField(maybeStyle) && isListObjectField(maybeList);
}
function isStyleObjectField(field) {
  if (!isRecord(field)) return false;
  if (field.name !== "style") return false;
  return isRecord(field.type) && field.type.jsonType === "string";
}
function isListObjectField(field) {
  if (!isRecord(field)) return false;
  if (field.name !== "list") return false;
  return isRecord(field.type) && field.type.jsonType === "string";
}
function isBlockChildrenObjectField(field) {
  if (!isRecord(field)) return false;
  if (field.name !== "children") return false;
  if (!isArraySchemaType(field.type)) return false;
  return field.type.of.some(isSpanSchemaType);
}
function findBlockType(type) {
  if (type.type) {
    return findBlockType(type.type);
  }
  if (type.name === "block") {
    return true;
  }
  return false;
}
function blockContentFeatures(blockContentType) {
  var _a, _b;
  if (!blockContentType) {
    throw new Error("Parameter 'blockContentType' required");
  }
  const blockType = blockContentType.of.find(findBlockType);
  if (!isBlockSchemaType(blockType)) {
    throw new Error("'block' type is not defined in this schema (required).");
  }
  const ofType = (_b = (_a = blockType.fields.find(isBlockChildrenObjectField)) == null ? void 0 : _a.type) == null ? void 0 : _b.of;
  if (!ofType) {
    throw new Error("No `of` declaration found for blocks `children` field");
  }
  const spanType = ofType.find(member => member.name === "span");
  if (!spanType) {
    throw new Error("No `span` type found in `block` schema type `children` definition");
  }
  const inlineObjectTypes = ofType.filter(inlineType => inlineType.name !== "span" && isObjectSchemaType(inlineType));
  const blockObjectTypes = blockContentType.of.filter(memberType => memberType.name !== blockType.name && isObjectSchemaType(memberType));
  return {
    styles: resolveEnabledStyles(blockType),
    decorators: resolveEnabledDecorators(spanType),
    annotations: resolveEnabledAnnotationTypes(spanType),
    lists: resolveEnabledListItems(blockType),
    types: {
      block: blockContentType,
      span: spanType,
      inlineObjects: inlineObjectTypes,
      blockObjects: blockObjectTypes
    }
  };
}
function resolveEnabledStyles(blockType) {
  const styleField = blockType.fields.find(isStyleObjectField);
  if (!styleField) {
    throw new Error("A field with name 'style' is not defined in the block type (required).");
  }
  const textStyles = getTitledListValuesFromEnumListOptions(styleField.type.options);
  if (textStyles.length === 0) {
    throw new Error("The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.");
  }
  return textStyles;
}
function resolveEnabledAnnotationTypes(spanType) {
  return spanType.annotations.map(annotation => ({
    blockEditor: annotation.blockEditor,
    title: annotation.title,
    type: annotation,
    value: annotation.name,
    icon: annotation.icon
  }));
}
function resolveEnabledDecorators(spanType) {
  return spanType.decorators;
}
function resolveEnabledListItems(blockType) {
  const listField = blockType.fields.find(isListObjectField);
  if (!listField) {
    throw new Error("A field with name 'list' is not defined in the block type (required).");
  }
  const listItems = getTitledListValuesFromEnumListOptions(listField.type.options);
  if (!listItems) {
    throw new Error("The list field need at least to be an empty array");
  }
  return listItems;
}
function getTitledListValuesFromEnumListOptions(options) {
  const list = options ? options.list : void 0;
  if (!Array.isArray(list)) {
    return [];
  }
  return list.map(item => isTitledListValue(item) ? item : {
    title: item,
    value: item
  });
}
const toString = Object.prototype.toString;
function resolveJsType(val) {
  switch (toString.call(val)) {
    case "[object Function]":
      return "function";
    case "[object Date]":
      return "date";
    case "[object RegExp]":
      return "regexp";
    case "[object Arguments]":
      return "arguments";
    case "[object Array]":
      return "array";
    case "[object String]":
      return "string";
  }
  if (val === null) {
    return "null";
  }
  if (val === void 0) {
    return "undefined";
  }
  if (val && typeof val === "object" && "nodeType" in val && val.nodeType === 1) {
    return "element";
  }
  if (val === Object(val)) {
    return "object";
  }
  return typeof val;
}
function whatwgRNG() {
  let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;
  const rnds8 = new Uint8Array(length);
  getRandomValues(rnds8);
  return rnds8;
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 256).toString(16).substring(1);
}
function randomKey(length) {
  return whatwgRNG(length).reduce((str, n) => str + byteToHex[n], "").slice(0, length);
}
const BLOCK_DEFAULT_STYLE = "normal";
const DEFAULT_BLOCK = Object.freeze({
  _type: "block",
  markDefs: [],
  style: BLOCK_DEFAULT_STYLE
});
const DEFAULT_SPAN = Object.freeze({
  _type: "span",
  marks: []
});
const HTML_BLOCK_TAGS = {
  p: DEFAULT_BLOCK,
  blockquote: _objectSpread(_objectSpread({}, DEFAULT_BLOCK), {}, {
    style: "blockquote"
  })
};
const HTML_SPAN_TAGS = {
  span: {
    object: "text"
  }
};
const HTML_LIST_CONTAINER_TAGS = {
  ol: {
    object: null
  },
  ul: {
    object: null
  }
};
const HTML_HEADER_TAGS = {
  h1: _objectSpread(_objectSpread({}, DEFAULT_BLOCK), {}, {
    style: "h1"
  }),
  h2: _objectSpread(_objectSpread({}, DEFAULT_BLOCK), {}, {
    style: "h2"
  }),
  h3: _objectSpread(_objectSpread({}, DEFAULT_BLOCK), {}, {
    style: "h3"
  }),
  h4: _objectSpread(_objectSpread({}, DEFAULT_BLOCK), {}, {
    style: "h4"
  }),
  h5: _objectSpread(_objectSpread({}, DEFAULT_BLOCK), {}, {
    style: "h5"
  }),
  h6: _objectSpread(_objectSpread({}, DEFAULT_BLOCK), {}, {
    style: "h6"
  })
};
const HTML_MISC_TAGS = {
  br: _objectSpread(_objectSpread({}, DEFAULT_BLOCK), {}, {
    style: BLOCK_DEFAULT_STYLE
  })
};
const HTML_DECORATOR_TAGS = {
  b: "strong",
  strong: "strong",
  i: "em",
  em: "em",
  u: "underline",
  s: "strike-through",
  strike: "strike-through",
  del: "strike-through",
  code: "code"
};
const HTML_LIST_ITEM_TAGS = {
  li: _objectSpread(_objectSpread({}, DEFAULT_BLOCK), {}, {
    style: BLOCK_DEFAULT_STYLE,
    level: 1,
    listItem: "bullet"
  })
};
const ELEMENT_MAP = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, HTML_BLOCK_TAGS), HTML_SPAN_TAGS), HTML_LIST_CONTAINER_TAGS), HTML_LIST_ITEM_TAGS), HTML_HEADER_TAGS), HTML_MISC_TAGS);
uniq(Object.values(ELEMENT_MAP).filter(tag => "style" in tag).map(tag => tag.style));
uniq(Object.values(HTML_DECORATOR_TAGS));
const _XPathResult = {
  ANY_TYPE: 0,
  NUMBER_TYPE: 1,
  STRING_TYPE: 2,
  BOOLEAN_TYPE: 3,
  UNORDERED_NODE_ITERATOR_TYPE: 4,
  ORDERED_NODE_ITERATOR_TYPE: 5,
  UNORDERED_NODE_SNAPSHOT_TYPE: 6,
  ORDERED_NODE_SNAPSHOT_TYPE: 7,
  ANY_UNORDERED_NODE_TYPE: 8,
  FIRST_ORDERED_NODE_TYPE: 9
};
const unwantedWordDocumentPaths = ["/html/text()", "/html/head/text()", "/html/body/text()", "/html/body/ul/text()", "/html/body/ol/text()", "//comment()", "//style", "//xml", "//script", "//meta", "//link"];
var preprocessHTML = (html, doc) => {
  var _a, _b, _c;
  const bodyTextNodes = doc.evaluate("/html/body/text()", doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
  for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {
    const node = bodyTextNodes.snapshotItem(i);
    const text = node.textContent || "";
    if (text.replace(/[^\S\n]+$/g, "")) {
      const newNode = doc.createElement("span");
      newNode.appendChild(doc.createTextNode(text));
      (_a = node.parentNode) == null ? void 0 : _a.replaceChild(newNode, node);
    } else {
      (_b = node.parentNode) == null ? void 0 : _b.removeChild(node);
    }
  }
  const unwantedNodes = doc.evaluate(unwantedWordDocumentPaths.join("|"), doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {
    const unwanted = unwantedNodes.snapshotItem(i);
    if (!unwanted) {
      continue;
    }
    (_c = unwanted.parentNode) == null ? void 0 : _c.removeChild(unwanted);
  }
  return doc;
};
const WORD_HTML_REGEX = /(class="?Mso|style=(?:"|')[^"]*?\bmso-|w:WordDocument|<o:\w+>|<\/font>)/;
const unwantedPaths = ["//o:p", "//span[@style='mso-list:Ignore']", "//span[@style='mso-list: Ignore']"];
const mappedPaths = ["//p[@class='MsoTocHeading']", "//p[@class='MsoTitle']", "//p[@class='MsoToaHeading']", "//p[@class='MsoSubtitle']", "//span[@class='MsoSubtleEmphasis']", "//span[@class='MsoIntenseEmphasis']"];
const elementMap = {
  MsoTocHeading: ["h3"],
  MsoTitle: ["h1"],
  MsoToaHeading: ["h2"],
  MsoSubtitle: ["h5"],
  MsoSubtleEmphasis: ["span", "em"],
  MsoIntenseEmphasis: ["span", "em", "strong"]
};
function isWordHtml(html) {
  return WORD_HTML_REGEX.test(html);
}
var preprocessWord = (html, doc) => {
  var _a;
  if (!isWordHtml(html)) {
    return doc;
  }
  const unwantedNodes = doc.evaluate(unwantedPaths.join("|"), doc, prefix => {
    if (prefix === "o") {
      return "urn:schemas-microsoft-com:office:office";
    }
    return null;
  }, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {
    const unwanted = unwantedNodes.snapshotItem(i);
    if (unwanted == null ? void 0 : unwanted.parentNode) {
      unwanted.parentNode.removeChild(unwanted);
    }
  }
  const mappedElements = doc.evaluate(mappedPaths.join("|"), doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
  for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {
    const mappedElm = mappedElements.snapshotItem(i);
    const tags = elementMap[mappedElm.className];
    const text = new Text(mappedElm.textContent || "");
    if (!tags) {
      continue;
    }
    const parentElement = document.createElement(tags[0]);
    let parent = parentElement;
    let child = parentElement;
    tags.slice(1).forEach(tag => {
      child = document.createElement(tag);
      parent.appendChild(child);
      parent = child;
    });
    child.appendChild(text);
    (_a = mappedElm == null ? void 0 : mappedElm.parentNode) == null ? void 0 : _a.replaceChild(parentElement, mappedElm);
  }
  return doc;
};
function isGoogleDocsDocument(el) {
  if (el.nodeType !== 1) {
    return false;
  }
  const id = el.getAttribute("id");
  return id && id.match(/^docs-internal-guid-/) && el.tagName === "B";
}
var preprocessGDocs = (html, doc) => {
  if (doc.body.firstElementChild && isGoogleDocsDocument(doc.body.firstElementChild)) {
    const childNodes = doc.evaluate("//*", doc, null, _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, null);
    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {
      const elm = childNodes.snapshotItem(i);
      elm == null ? void 0 : elm.setAttribute("data-is-google-docs", "true");
    }
    doc.body.firstElementChild.replaceWith(...Array.from(doc.body.firstElementChild.childNodes));
    return doc;
  }
  return doc;
};
var preprocessors = [preprocessWord, preprocessGDocs, preprocessHTML];
function createRuleOptions(blockContentType) {
  const features = blockContentFeatures(blockContentType);
  const enabledBlockStyles = features.styles.map(item => item.value || item.title);
  const enabledSpanDecorators = features.decorators.map(item => item.value || item.title);
  const enabledBlockAnnotations = features.annotations.map(item => item.value || item.title || "");
  return {
    enabledBlockStyles,
    enabledSpanDecorators,
    enabledBlockAnnotations
  };
}
function tagName(el) {
  if (el && "tagName" in el) {
    return el.tagName.toLowerCase();
  }
  return void 0;
}
function preprocess(html, parseHtml) {
  const compactHtml = html.trim().replace(/\s\s+/g, " ").replace(/[\r\n]/g, " ");
  const doc = parseHtml(compactHtml);
  preprocessors.forEach(processor => {
    processor(html, doc);
  });
  return doc;
}
function defaultParseHtml() {
  if (resolveJsType(DOMParser) === "undefined") {
    throw new Error("The native `DOMParser` global which the `Html` deserializer uses by default is not present in this environment. You must supply the `options.parseHtml` function instead.");
  }
  return html => {
    return new DOMParser().parseFromString(html, "text/html");
  };
}
function flattenNestedBlocks(blocks) {
  let depth = 0;
  const flattened = [];
  const traverse = nodes => {
    const toRemove = [];
    nodes.forEach(node => {
      if (depth === 0) {
        flattened.push(node);
      }
      if (isBlock(node)) {
        if (depth > 0) {
          toRemove.push(node);
          flattened.push(node);
        }
        depth++;
        traverse(node.children);
      }
      if (node._type === "__block") {
        toRemove.push(node);
        flattened.push(node.block);
      }
    });
    toRemove.forEach(node => {
      nodes.splice(nodes.indexOf(node), 1);
    });
    depth--;
  };
  traverse(blocks);
  return flattened;
}
function nextSpan(block, index) {
  const next = block.children[index + 1];
  return next && next._type === "span" ? next : null;
}
function prevSpan(block, index) {
  const prev = block.children[index - 1];
  return prev && prev._type === "span" ? prev : null;
}
function isWhiteSpaceChar(text) {
  return ["\xA0", " "].includes(text);
}
function trimWhitespace(blocks) {
  blocks.forEach(block => {
    if (!isBlock(block)) {
      return;
    }
    block.children.forEach((child, index) => {
      if (child._type !== "span") {
        return;
      }
      const nextChild = nextSpan(block, index);
      const prevChild = prevSpan(block, index);
      if (index === 0) {
        child.text = child.text.replace(/^[^\S\n]+/g, "");
      }
      if (index === block.children.length - 1) {
        child.text = child.text.replace(/[^\S\n]+$/g, "");
      }
      if (/\s/.test(child.text.substring(child.text.length - 1)) && nextChild && /\s/.test(nextChild.text.substring(0, 1))) {
        child.text = child.text.replace(/[^\S\n]+$/g, "");
      }
      if (/\s/.test(child.text.substring(0, 1)) && prevChild && /\s/.test(prevChild.text.substring(prevChild.text.length - 1))) {
        child.text = child.text.replace(/^[^\S\n]+/g, "");
      }
      if (!child.text) {
        block.children.splice(index, 1);
      }
      if (prevChild && isEqual(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text)) {
        prevChild.text += " ";
        block.children.splice(index, 1);
      } else if (nextChild && isEqual(nextChild.marks, child.marks) && isWhiteSpaceChar(child.text)) {
        nextChild.text = " ".concat(nextChild.text);
        block.children.splice(index, 1);
      }
    });
  });
  return blocks;
}
function ensureRootIsBlocks(blocks) {
  return blocks.reduce((memo, node, i, original) => {
    if (node._type === "block") {
      memo.push(node);
      return memo;
    }
    if (node._type === "__block") {
      memo.push(node.block);
      return memo;
    }
    const lastBlock = memo[memo.length - 1];
    if (i > 0 && !isBlock(original[i - 1]) && isBlock(lastBlock)) {
      lastBlock.children.push(node);
      return memo;
    }
    const block = _objectSpread(_objectSpread({}, DEFAULT_BLOCK), {}, {
      children: [node]
    });
    memo.push(block);
    return memo;
  }, []);
}
function isNodeList(node) {
  return Object.prototype.toString.call(node) == "[object NodeList]";
}
function isMinimalSpan(node) {
  return node._type === "span";
}
function isMinimalBlock(node) {
  return node._type === "block";
}
function isPlaceholderDecorator(node) {
  return node._type === "__decorator";
}
function isPlaceholderAnnotation(node) {
  return node._type === "__annotation";
}
function isElement(node) {
  return node.nodeType === 1;
}
function resolveListItem(listNodeTagName) {
  let listStyle;
  switch (listNodeTagName) {
    case "ul":
      listStyle = "bullet";
      break;
    case "ol":
      listStyle = "number";
      break;
    default:
      listStyle = "bullet";
  }
  return listStyle;
}
function createHTMLRules(blockContentType, options) {
  return [{
    deserialize(el) {
      const isValidWhiteSpace = el.nodeType === 3 && (el.textContent || "").replace(/[\r\n]/g, " ").replace(/\s\s+/g, " ") === " " && el.nextSibling && el.nextSibling.nodeType !== 3 && el.previousSibling && el.previousSibling.nodeType !== 3;
      const isValidText = (isValidWhiteSpace || el.textContent !== " ") && tagName(el.parentNode) !== "body";
      if (el.nodeName === "#text" && isValidText) {
        return _objectSpread(_objectSpread({}, DEFAULT_SPAN), {}, {
          marks: [],
          text: (el.textContent || "").replace(/\s\s+/g, " ")
        });
      }
      return void 0;
    }
  }, {
    deserialize(el, next) {
      if (tagName(el) !== "blockquote") {
        return void 0;
      }
      const blocks = _objectSpread(_objectSpread({}, HTML_BLOCK_TAGS), HTML_HEADER_TAGS);
      delete blocks.blockquote;
      const children = [];
      el.childNodes.forEach((node, index) => {
        if (node.nodeType === 1 && Object.keys(blocks).includes(node.localName.toLowerCase())) {
          if (!el.ownerDocument) {
            return;
          }
          const span = el.ownerDocument.createElement("span");
          span.appendChild(el.ownerDocument.createTextNode("\r"));
          node.childNodes.forEach(cn => {
            span.appendChild(cn.cloneNode(true));
          });
          if (index !== el.childNodes.length) {
            span.appendChild(el.ownerDocument.createTextNode("\r"));
          }
          children.push(span);
        } else {
          children.push(node);
        }
      });
      return {
        _type: "block",
        style: "blockquote",
        markDefs: [],
        children: next(children)
      };
    }
  }, {
    deserialize(el, next) {
      const blocks = _objectSpread(_objectSpread({}, HTML_BLOCK_TAGS), HTML_HEADER_TAGS);
      const tag = tagName(el);
      let block = tag ? blocks[tag] : void 0;
      if (!block) {
        return void 0;
      }
      if (el.parentNode && tagName(el) === "li") {
        return next(el.childNodes);
      }
      if (!options.enabledBlockStyles.includes(block.style)) {
        block = DEFAULT_BLOCK;
      }
      return _objectSpread(_objectSpread({}, block), {}, {
        children: next(el.childNodes)
      });
    }
  }, {
    deserialize(el, next) {
      const tag = tagName(el);
      if (!tag || !(tag in HTML_SPAN_TAGS)) {
        return void 0;
      }
      return next(el.childNodes);
    }
  }, {
    deserialize(el, next) {
      const div = tagName(el) === "div";
      if (!div) {
        return void 0;
      }
      return next(el.childNodes);
    }
  }, {
    deserialize(el, next) {
      const tag = tagName(el);
      if (!tag || !(tag in HTML_LIST_CONTAINER_TAGS)) {
        return void 0;
      }
      return next(el.childNodes);
    }
  }, {
    deserialize(el) {
      if (tagName(el) === "br") {
        return _objectSpread(_objectSpread({}, DEFAULT_SPAN), {}, {
          text: "\n"
        });
      }
      return void 0;
    }
  }, {
    deserialize(el, next) {
      const tag = tagName(el);
      const listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : void 0;
      const parentTag = tagName(el.parentNode) || "";
      if (!listItem || !el.parentNode || !HTML_LIST_CONTAINER_TAGS[parentTag]) {
        return void 0;
      }
      listItem.listItem = resolveListItem(parentTag);
      return _objectSpread(_objectSpread({}, listItem), {}, {
        children: next(el.childNodes)
      });
    }
  }, {
    deserialize(el, next) {
      const decorator = HTML_DECORATOR_TAGS[tagName(el) || ""];
      if (!decorator || !options.enabledSpanDecorators.includes(decorator)) {
        return void 0;
      }
      return {
        _type: "__decorator",
        name: decorator,
        children: next(el.childNodes)
      };
    }
  }, {
    deserialize(el, next) {
      if (tagName(el) != "a") {
        return void 0;
      }
      const linkEnabled = options.enabledBlockAnnotations.includes("link");
      const href = isElement(el) && el.getAttribute("href");
      if (!href) {
        return next(el.childNodes);
      }
      let markDef;
      if (linkEnabled) {
        markDef = {
          _key: randomKey(12),
          _type: "link",
          href
        };
        return {
          _type: "__annotation",
          markDef,
          children: next(el.childNodes)
        };
      }
      return el.appendChild(el.ownerDocument.createTextNode(" (".concat(href, ")"))) && next(el.childNodes);
    }
  }];
}
const LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS);
function isEmphasis(el) {
  const style = isElement(el) && el.getAttribute("style");
  return /font-style:italic/.test(style || "");
}
function isStrong(el) {
  const style = isElement(el) && el.getAttribute("style");
  return /font-weight:700/.test(style || "");
}
function isGoogleDocs(el) {
  return isElement(el) && Boolean(el.getAttribute("data-is-google-docs"));
}
function getListItemStyle$1(el) {
  const parentTag = tagName(el.parentNode);
  if (parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)) {
    return void 0;
  }
  return tagName(el.parentNode) === "ul" ? "bullet" : "number";
}
function getListItemLevel$1(el) {
  let level = 0;
  if (tagName(el) === "li") {
    let parentNode = el.parentNode;
    while (parentNode) {
      const parentTag = tagName(parentNode);
      if (parentTag && LIST_CONTAINER_TAGS.includes(parentTag)) {
        level++;
      }
      parentNode = parentNode.parentNode;
    }
  } else {
    level = 1;
  }
  return level;
}
const blocks = _objectSpread(_objectSpread({}, HTML_BLOCK_TAGS), HTML_HEADER_TAGS);
function getBlockStyle(el, enabledBlockStyles) {
  const childTag = tagName(el.firstChild);
  const block = childTag && blocks[childTag];
  if (!block) {
    return BLOCK_DEFAULT_STYLE;
  }
  if (!enabledBlockStyles.includes(block.style)) {
    return BLOCK_DEFAULT_STYLE;
  }
  return block.style;
}
function createGDocsRules(_blockContentType, options) {
  return [{
    deserialize(el) {
      if (isElement(el) && tagName(el) === "span" && isGoogleDocs(el)) {
        const span = _objectSpread(_objectSpread({}, DEFAULT_SPAN), {}, {
          marks: [],
          text: el.innerText
        });
        if (isStrong(el)) {
          span.marks.push("strong");
        }
        if (isEmphasis(el)) {
          span.marks.push("em");
        }
        return span;
      }
      return void 0;
    }
  }, {
    deserialize(el, next) {
      var _a;
      if (tagName(el) === "li" && isGoogleDocs(el)) {
        return _objectSpread(_objectSpread({}, DEFAULT_BLOCK), {}, {
          listItem: getListItemStyle$1(el),
          level: getListItemLevel$1(el),
          style: getBlockStyle(el, options.enabledBlockStyles),
          children: next(((_a = el.firstChild) == null ? void 0 : _a.childNodes) || [])
        });
      }
      return void 0;
    }
  }];
}
function getListItemStyle(el) {
  const style = isElement(el) && el.getAttribute("style");
  if (!style) {
    return void 0;
  }
  if (!style.match(/lfo\d+/)) {
    return void 0;
  }
  return style.match("lfo1") ? "bullet" : "number";
}
function getListItemLevel(el) {
  const style = isElement(el) && el.getAttribute("style");
  if (!style) {
    return void 0;
  }
  const levelMatch = style.match(/level\d+/);
  if (!levelMatch) {
    return void 0;
  }
  const [level] = levelMatch[0].match(/\d/) || [];
  const levelNum = level ? parseInt(level, 10) : 1;
  return levelNum || 1;
}
function isWordListElement(el) {
  return isElement(el) && el.className ? el.className === "MsoListParagraphCxSpFirst" || el.className === "MsoListParagraphCxSpMiddle" || el.className === "MsoListParagraphCxSpLast" : false;
}
function createWordRules() {
  return [{
    deserialize(el, next) {
      if (tagName(el) === "p" && isWordListElement(el)) {
        return _objectSpread(_objectSpread({}, DEFAULT_BLOCK), {}, {
          listItem: getListItemStyle(el),
          level: getListItemLevel(el),
          style: BLOCK_DEFAULT_STYLE,
          children: next(el.childNodes)
        });
      }
      return void 0;
    }
  }];
}
function createRules(blockContentType, options) {
  return [...createWordRules(), ...createGDocsRules(blockContentType, options), ...createHTMLRules(blockContentType, options)];
}
class HtmlDeserializer {
  constructor(blockContentType) {
    var _this = this;
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this._markDefs = [];
    this.deserialize = html => {
      this._markDefs = [];
      const {
        parseHtml
      } = this;
      const fragment = parseHtml(html);
      const children = Array.from(fragment.childNodes);
      const blocks = trimWhitespace(flattenNestedBlocks(ensureRootIsBlocks(this.deserializeElements(children))));
      if (this._markDefs.length > 0) {
        blocks.filter(block => block._type === "block").forEach(block => {
          block.markDefs = block.markDefs || [];
          block.markDefs = block.markDefs.concat(this._markDefs.filter(def => {
            return flatten(block.children.map(child => child.marks || [])).includes(def._key);
          }));
        });
      }
      const type = this.blockContentType.of.find(findBlockType);
      if (!type) {
        return blocks;
      }
      return blocks.map(block => {
        if (block._type === "block") {
          block._type = type.name;
        }
        return block;
      });
    };
    this.deserializeElements = function () {
      let elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      let nodes = [];
      elements.forEach(element => {
        nodes = nodes.concat(_this.deserializeElement(element));
      });
      return nodes;
    };
    this.deserializeElement = element => {
      var _a, _b;
      const next = elements => {
        if (isNodeList(elements)) {
          return this.deserializeElements(Array.from(elements));
        }
        if (Array.isArray(elements)) {
          return this.deserializeElements(elements);
        }
        if (!elements) {
          return void 0;
        }
        return this.deserializeElement(elements);
      };
      const block = props => {
        return {
          _type: "__block",
          block: props
        };
      };
      let node;
      for (let i = 0; i < this.rules.length; i++) {
        const rule = this.rules[i];
        if (!rule.deserialize) {
          continue;
        }
        const ret = rule.deserialize(element, next, block);
        const type = resolveJsType(ret);
        if (type !== "array" && type !== "object" && type !== "null" && type !== "undefined") {
          throw new Error("A rule returned an invalid deserialized representation: \"".concat(node, "\"."));
        }
        if (ret === void 0) {
          continue;
        } else if (ret === null) {
          throw new Error("Deserializer rule returned `null`");
        } else if (Array.isArray(ret)) {
          node = ret;
        } else if (isPlaceholderDecorator(ret)) {
          node = this.deserializeDecorator(ret);
        } else if (isPlaceholderAnnotation(ret)) {
          node = this.deserializeAnnotation(ret);
        } else {
          node = ret;
        }
        if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && "listItem" in ret) {
          let parent = (_a = element.parentNode) == null ? void 0 : _a.parentNode;
          while (parent && tagName(parent) === "li") {
            parent = (_b = parent.parentNode) == null ? void 0 : _b.parentNode;
            ret.level = ret.level ? ret.level + 1 : 1;
          }
        }
        if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && ret.style === "blockquote") {
          ret.children.forEach((child, index) => {
            if (isMinimalSpan(child) && child.text === "\r") {
              child.text = "\n\n";
              if (index === 0 || index === ret.children.length - 1) {
                ret.children.splice(index, 1);
              }
            }
          });
        }
        break;
      }
      return node || next(element.childNodes) || [];
    };
    this.deserializeDecorator = decorator => {
      const {
        name
      } = decorator;
      const applyDecorator = node => {
        if (isPlaceholderDecorator(node)) {
          return this.deserializeDecorator(node);
        } else if (isMinimalSpan(node)) {
          node.marks = node.marks || [];
          if (node.text.trim()) {
            node.marks.unshift(name);
          }
        } else if ("children" in node && Array.isArray(node.children)) {
          const block = node;
          block.children = block.children.map(applyDecorator);
        }
        return node;
      };
      return decorator.children.reduce((children, node) => {
        const ret = applyDecorator(node);
        if (Array.isArray(ret)) {
          return children.concat(ret);
        }
        children.push(ret);
        return children;
      }, []);
    };
    this.deserializeAnnotation = annotation => {
      const {
        markDef
      } = annotation;
      this._markDefs.push(markDef);
      const applyAnnotation = node => {
        if (isPlaceholderAnnotation(node)) {
          return this.deserializeAnnotation(node);
        } else if (isMinimalSpan(node)) {
          node.marks = node.marks || [];
          if (node.text.trim()) {
            node.marks.unshift(markDef._key);
          }
        } else if ("children" in node && Array.isArray(node.children)) {
          const block = node;
          block.children = block.children.map(applyAnnotation);
        }
        return node;
      };
      return annotation.children.reduce((children, node) => {
        const ret = applyAnnotation(node);
        if (Array.isArray(ret)) {
          return children.concat(ret);
        }
        children.push(ret);
        return children;
      }, []);
    };
    const {
      rules = []
    } = options;
    if (!blockContentType) {
      throw new Error("Parameter 'blockContentType' is required");
    }
    const standardRules = createRules(blockContentType, createRuleOptions(blockContentType));
    this.rules = [...rules, ...standardRules];
    const parseHtml = options.parseHtml || defaultParseHtml();
    this.blockContentType = blockContentType;
    this.parseHtml = html => {
      const doc = preprocess(html, parseHtml);
      return doc.body;
    };
  }
}
function normalizeBlock(node) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (node._type !== (options.blockTypeName || "block")) {
    return "_key" in node ? node : _objectSpread(_objectSpread({}, node), {}, {
      _key: randomKey(12)
    });
  }
  const block = _objectSpread({
    _key: randomKey(12),
    children: [],
    markDefs: []
  }, node);
  const lastChild = block.children[block.children.length - 1];
  if (!lastChild) {
    block.children = [{
      _type: "span",
      _key: "".concat(block._key, 0),
      text: "",
      marks: []
    }];
    return block;
  }
  const usedMarkDefs = [];
  const allowedDecorators = options.allowedDecorators && Array.isArray(options.allowedDecorators) ? options.allowedDecorators : false;
  block.children = block.children.reduce((acc, child) => {
    const previousChild = acc[acc.length - 1];
    if (previousChild && isSpan(child) && isSpan(previousChild) && isEqual(previousChild.marks, child.marks)) {
      if (lastChild && lastChild === child && child.text === "" && block.children.length > 1) {
        return acc;
      }
      previousChild.text += child.text;
      return acc;
    }
    acc.push(child);
    return acc;
  }, []).map((child, index) => {
    if (!child) {
      throw new Error("missing child");
    }
    child._key = "".concat(block._key).concat(index);
    if (isSpan(child)) {
      if (!child.marks) {
        child.marks = [];
      } else if (allowedDecorators) {
        child.marks = child.marks.filter(mark => {
          const isAllowed = allowedDecorators.includes(mark);
          const isUsed = block.markDefs.some(def => def._key === mark);
          return isAllowed || isUsed;
        });
      }
      usedMarkDefs.push(...child.marks);
    }
    return child;
  });
  block.markDefs = block.markDefs.filter(markDef => usedMarkDefs.includes(markDef._key));
  return block;
}
function htmlToBlocks(html, blockContentType) {
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const deserializer = new HtmlDeserializer(blockContentType, options);
  return deserializer.deserialize(html).map(block => normalizeBlock(block));
}
function getBlockContentFeatures(blockContentType) {
  return blockContentFeatures(blockContentType);
}
export { getBlockContentFeatures, htmlToBlocks, normalizeBlock, randomKey };
//# sourceMappingURL=index.esm.js.map
