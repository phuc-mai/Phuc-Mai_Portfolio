{"version":3,"file":"index.esm.js","sources":["../../types/lib/index.esm.js","../src/util/findBlockType.ts","../src/util/blockContentTypeFeatures.ts","../src/util/resolveJsType.ts","../src/util/randomKey.ts","../src/constants.ts","../src/HtmlDeserializer/preprocessors/xpathResult.ts","../src/HtmlDeserializer/preprocessors/html.ts","../src/HtmlDeserializer/preprocessors/word.ts","../src/HtmlDeserializer/preprocessors/gdocs.ts","../src/HtmlDeserializer/preprocessors/index.ts","../src/HtmlDeserializer/helpers.ts","../src/HtmlDeserializer/rules/html.ts","../src/HtmlDeserializer/rules/gdocs.ts","../src/HtmlDeserializer/rules/word.ts","../src/HtmlDeserializer/rules/index.ts","../src/HtmlDeserializer/index.ts","../src/util/normalizeBlock.ts","../src/index.ts"],"sourcesContent":["function isObject(obj) {\n  return typeof obj === \"object\" && obj !== null && !Array.isArray(obj);\n}\nfunction isReference(reference) {\n  return isObject(reference) && typeof reference._ref === \"string\";\n}\nfunction isImage(value) {\n  return isObject(value) && isReference(value.asset) && value.asset._ref.startsWith(\"image-\");\n}\nfunction isCrossDatasetReference(reference) {\n  return isObject(reference) && typeof reference._ref === \"string\" && typeof reference._dataset === \"string\" && typeof reference._projectId === \"string\";\n}\nfunction isSanityDocument(document) {\n  return isObject(document) && typeof document._id === \"string\" && typeof document._type === \"string\";\n}\nfunction isTypedObject(obj) {\n  return isObject(obj) && typeof obj._type === \"string\";\n}\nfunction isKeyedObject(obj) {\n  return isObject(obj) && typeof obj._key === \"string\";\n}\nfunction isValidationErrorMarker(marker) {\n  return marker.level === \"error\";\n}\nfunction isValidationWarningMarker(marker) {\n  return marker.level === \"warning\";\n}\nfunction isValidationInfoMarker(marker) {\n  return marker.level === \"info\";\n}\nfunction isCreateMutation(mutation) {\n  return \"create\" in mutation;\n}\nfunction isCreateIfNotExistsMutation(mutation) {\n  return \"createIfNotExists\" in mutation;\n}\nfunction isCreateOrReplaceMutation(mutation) {\n  return \"createOrReplace\" in mutation;\n}\nfunction isDeleteMutation(mutation) {\n  return \"delete\" in mutation;\n}\nfunction isPatchMutation(mutation) {\n  return \"patch\" in mutation;\n}\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nconst reIndexTuple = /^\\d*:\\d*$/;\nfunction isIndexSegment(segment) {\n  return typeof segment === \"number\" || typeof segment === \"string\" && /^\\[\\d+\\]$/.test(segment);\n}\nfunction isKeySegment(segment) {\n  if (typeof segment === \"string\") {\n    return reKeySegment.test(segment.trim());\n  }\n  return typeof segment === \"object\" && \"_key\" in segment;\n}\nfunction isIndexTuple(segment) {\n  if (typeof segment === \"string\" && reIndexTuple.test(segment)) {\n    return true;\n  }\n  if (!Array.isArray(segment) || segment.length !== 2) {\n    return false;\n  }\n  const [from, to] = segment;\n  return (typeof from === \"number\" || from === \"\") && (typeof to === \"number\" || to === \"\");\n}\nfunction isRecord$1(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction isBlock(value) {\n  return isRecord$1(value) && typeof value._type === \"string\" && typeof value.style === \"string\" && Array.isArray(value.children) && Array.isArray(value.markDefs);\n}\nfunction isSpan(value) {\n  return isRecord$1(value) && value._type === \"span\" && typeof value.text === \"string\" && Array.isArray(value.marks);\n}\nfunction isRecord(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction isDocumentSchemaType(type) {\n  if (!isObjectSchemaType(type)) {\n    return false;\n  }\n  let current = type;\n  while (current) {\n    if (current.name === \"document\") {\n      return true;\n    }\n    current = current.type;\n  }\n  return false;\n}\nfunction isObjectSchemaType(type) {\n  if (!isRecord(type)) return false;\n  return type.jsonType === \"object\";\n}\nfunction isArraySchemaType(type) {\n  if (!isRecord(type)) return false;\n  return type.jsonType === \"array\";\n}\nfunction isArrayOfObjectsSchemaType(type) {\n  return isArraySchemaType(type) && type.of.every(memberType => isObjectSchemaType(memberType));\n}\nfunction isArrayOfPrimitivesSchemaType(type) {\n  return isArraySchemaType(type) && type.of.every(memberType => isPrimitiveSchemaType(memberType));\n}\nfunction isBooleanSchemaType(type) {\n  if (!isRecord(type)) return false;\n  return type.jsonType === \"boolean\";\n}\nfunction isStringSchemaType(type) {\n  if (!isRecord(type)) return false;\n  return type.jsonType === \"string\";\n}\nfunction isNumberSchemaType(type) {\n  if (!isRecord(type)) return false;\n  return type.jsonType === \"number\";\n}\nfunction isPrimitiveSchemaType(type) {\n  return isBooleanSchemaType(type) || isStringSchemaType(type) || isNumberSchemaType(type);\n}\nfunction isReferenceSchemaType(type) {\n  return isRecord(type) && (type.name === \"reference\" || isReferenceSchemaType(type.type));\n}\nfunction isCrossDatasetReferenceSchemaType(type) {\n  return isRecord(type) && (type.name === \"crossDatasetReference\" || isCrossDatasetReferenceSchemaType(type.type));\n}\nfunction isTitledListValue(item) {\n  return typeof item === \"object\" && item !== null && \"title\" in item && \"value\" in item;\n}\nfunction isSpanSchemaType(type) {\n  if (!isRecord(type)) return false;\n  return Array.isArray(type.annotations) && Array.isArray(type.decorators);\n}\nfunction isBlockSchemaType(type) {\n  if (!isRecord(type)) return false;\n  if (!Array.isArray(type.fields)) return false;\n  const [maybeSpanChildren, maybeStyle, maybeList] = type.fields;\n  return isBlockChildrenObjectField(maybeSpanChildren) && isStyleObjectField(maybeStyle) && isListObjectField(maybeList);\n}\nfunction isStyleObjectField(field) {\n  if (!isRecord(field)) return false;\n  if (field.name !== \"style\") return false;\n  return isRecord(field.type) && field.type.jsonType === \"string\";\n}\nfunction isListObjectField(field) {\n  if (!isRecord(field)) return false;\n  if (field.name !== \"list\") return false;\n  return isRecord(field.type) && field.type.jsonType === \"string\";\n}\nfunction isBlockChildrenObjectField(field) {\n  if (!isRecord(field)) return false;\n  if (field.name !== \"children\") return false;\n  if (!isArraySchemaType(field.type)) return false;\n  return field.type.of.some(isSpanSchemaType);\n}\nfunction defineType(schemaDefinition, defineOptions) {\n  return schemaDefinition;\n}\nfunction defineField(schemaField, defineOptions) {\n  return schemaField;\n}\nfunction defineArrayMember(arrayOfSchema, defineOptions) {\n  return arrayOfSchema;\n}\nfunction typed(input) {\n  return input;\n}\nfunction isCreateSquashedMutation(mutation) {\n  return \"createSquashed\" in mutation;\n}\nfunction isValidationError(node) {\n  return node.level === \"error\";\n}\nfunction isValidationWarning(node) {\n  return node.level === \"warning\";\n}\nfunction isValidationInfo(node) {\n  return node.level === \"info\";\n}\nexport { defineArrayMember, defineField, defineType, isArrayOfObjectsSchemaType, isArrayOfPrimitivesSchemaType, isArraySchemaType, isBlock, isBlockChildrenObjectField, isBlockSchemaType, isBooleanSchemaType, isCreateIfNotExistsMutation, isCreateMutation, isCreateOrReplaceMutation, isCreateSquashedMutation, isCrossDatasetReference, isCrossDatasetReferenceSchemaType, isDeleteMutation, isDocumentSchemaType, isImage, isIndexSegment, isIndexTuple, isKeySegment, isKeyedObject, isListObjectField, isNumberSchemaType, isObjectSchemaType, isPatchMutation, isPrimitiveSchemaType, isReference, isReferenceSchemaType, isSanityDocument, isSpan, isSpanSchemaType, isStringSchemaType, isStyleObjectField, isTitledListValue, isTypedObject, isValidationError, isValidationErrorMarker, isValidationInfo, isValidationInfoMarker, isValidationWarning, isValidationWarningMarker, typed };\n//# sourceMappingURL=index.esm.js.map\n","import type {BlockSchemaType, SchemaType} from '@sanity/types'\n\nexport function findBlockType(type: SchemaType): type is BlockSchemaType {\n  if (type.type) {\n    return findBlockType(type.type)\n  }\n\n  if (type.name === 'block') {\n    return true\n  }\n\n  return false\n}\n","import {\n  ArraySchemaType,\n  BlockSchemaType,\n  EnumListProps,\n  isBlockChildrenObjectField,\n  isBlockSchemaType,\n  isListObjectField,\n  isObjectSchemaType,\n  isStyleObjectField,\n  isTitledListValue,\n  ObjectSchemaType,\n  SpanSchemaType,\n  TitledListValue,\n} from '@sanity/types'\nimport {BlockContentFeatures, ResolvedAnnotationType} from '../types'\nimport {findBlockType} from './findBlockType'\n\n// Helper method for describing a blockContentType's feature set\nexport default function blockContentFeatures(\n  blockContentType: ArraySchemaType\n): BlockContentFeatures {\n  if (!blockContentType) {\n    throw new Error(\"Parameter 'blockContentType' required\")\n  }\n\n  const blockType = blockContentType.of.find(findBlockType)\n  if (!isBlockSchemaType(blockType)) {\n    throw new Error(\"'block' type is not defined in this schema (required).\")\n  }\n\n  const ofType = blockType.fields.find(isBlockChildrenObjectField)?.type?.of\n  if (!ofType) {\n    throw new Error('No `of` declaration found for blocks `children` field')\n  }\n\n  const spanType = ofType.find((member): member is SpanSchemaType => member.name === 'span')\n  if (!spanType) {\n    throw new Error('No `span` type found in `block` schema type `children` definition')\n  }\n\n  const inlineObjectTypes = ofType.filter(\n    (inlineType): inlineType is ObjectSchemaType =>\n      inlineType.name !== 'span' && isObjectSchemaType(inlineType)\n  )\n\n  const blockObjectTypes = blockContentType.of.filter(\n    (memberType): memberType is ObjectSchemaType =>\n      memberType.name !== blockType.name && isObjectSchemaType(memberType)\n  )\n\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    annotations: resolveEnabledAnnotationTypes(spanType),\n    lists: resolveEnabledListItems(blockType),\n    types: {\n      block: blockContentType,\n      span: spanType,\n      inlineObjects: inlineObjectTypes,\n      blockObjects: blockObjectTypes,\n    },\n  }\n}\n\nfunction resolveEnabledStyles(blockType: BlockSchemaType): TitledListValue<string>[] {\n  const styleField = blockType.fields.find(isStyleObjectField)\n  if (!styleField) {\n    throw new Error(\"A field with name 'style' is not defined in the block type (required).\")\n  }\n\n  const textStyles = getTitledListValuesFromEnumListOptions(styleField.type.options)\n  if (textStyles.length === 0) {\n    throw new Error(\n      'The style fields need at least one style ' +\n        \"defined. I.e: {title: 'Normal', value: 'normal'}.\"\n    )\n  }\n\n  return textStyles\n}\n\nfunction resolveEnabledAnnotationTypes(spanType: SpanSchemaType): ResolvedAnnotationType[] {\n  return spanType.annotations.map((annotation) => ({\n    blockEditor: annotation.blockEditor,\n    title: annotation.title,\n    type: annotation,\n    value: annotation.name,\n    icon: annotation.icon,\n  }))\n}\n\nfunction resolveEnabledDecorators(spanType: SpanSchemaType): TitledListValue<string>[] {\n  return spanType.decorators\n}\n\nfunction resolveEnabledListItems(blockType: BlockSchemaType): TitledListValue<string>[] {\n  const listField = blockType.fields.find(isListObjectField)\n  if (!listField) {\n    throw new Error(\"A field with name 'list' is not defined in the block type (required).\")\n  }\n\n  const listItems = getTitledListValuesFromEnumListOptions(listField.type.options)\n  if (!listItems) {\n    throw new Error('The list field need at least to be an empty array')\n  }\n\n  return listItems\n}\n\nfunction getTitledListValuesFromEnumListOptions(\n  options: EnumListProps<string> | undefined\n): TitledListValue<string>[] {\n  const list = options ? options.list : undefined\n  if (!Array.isArray(list)) {\n    return []\n  }\n\n  return list.map((item) => (isTitledListValue(item) ? item : {title: item, value: item}))\n}\n","const toString = Object.prototype.toString\n\n// Copied from https://github.com/ForbesLindesay/type-of\n// but inlined to have fine grained control\nexport function resolveJsType(val: unknown) {\n  switch (toString.call(val)) {\n    case '[object Function]':\n      return 'function'\n    case '[object Date]':\n      return 'date'\n    case '[object RegExp]':\n      return 'regexp'\n    case '[object Arguments]':\n      return 'arguments'\n    case '[object Array]':\n      return 'array'\n    case '[object String]':\n      return 'string'\n    default:\n  }\n\n  if (val === null) {\n    return 'null'\n  }\n\n  if (val === undefined) {\n    return 'undefined'\n  }\n\n  if (\n    val &&\n    typeof val === 'object' &&\n    'nodeType' in val &&\n    (val as {nodeType: unknown}).nodeType === 1\n  ) {\n    return 'element'\n  }\n\n  if (val === Object(val)) {\n    return 'object'\n  }\n\n  return typeof val\n}\n","import getRandomValues from 'get-random-values-esm'\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  getRandomValues(rnds8)\n  return rnds8\n}\n\nconst byteToHex: string[] = []\nfor (let i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substring(1)\n}\n\n/**\n * Generate a random key of the given length\n *\n * @param length - Length of string to generate\n * @returns A string of the given length\n * @public\n */\nexport function randomKey(length: number): string {\n  return whatwgRNG(length)\n    .reduce((str, n) => str + byteToHex[n], '')\n    .slice(0, length)\n}\n","import {uniq} from 'lodash'\n\nexport interface PartialBlock {\n  _type: string\n  markDefs: string[]\n  style: string\n  level?: number\n  listItem?: string\n}\n\nexport const BLOCK_DEFAULT_STYLE = 'normal'\n\nexport const DEFAULT_BLOCK: PartialBlock = Object.freeze({\n  _type: 'block',\n  markDefs: [],\n  style: BLOCK_DEFAULT_STYLE,\n})\n\nexport const DEFAULT_SPAN = Object.freeze({\n  _type: 'span',\n  marks: [] as string[],\n})\n\nexport const HTML_BLOCK_TAGS = {\n  p: DEFAULT_BLOCK,\n  blockquote: {...DEFAULT_BLOCK, style: 'blockquote'} as PartialBlock,\n}\n\nexport const HTML_SPAN_TAGS = {\n  span: {object: 'text'},\n}\n\nexport const HTML_LIST_CONTAINER_TAGS: Record<string, {object: null} | undefined> = {\n  ol: {object: null},\n  ul: {object: null},\n}\n\nexport const HTML_HEADER_TAGS: Record<string, PartialBlock | undefined> = {\n  h1: {...DEFAULT_BLOCK, style: 'h1'},\n  h2: {...DEFAULT_BLOCK, style: 'h2'},\n  h3: {...DEFAULT_BLOCK, style: 'h3'},\n  h4: {...DEFAULT_BLOCK, style: 'h4'},\n  h5: {...DEFAULT_BLOCK, style: 'h5'},\n  h6: {...DEFAULT_BLOCK, style: 'h6'},\n}\n\nexport const HTML_MISC_TAGS = {\n  br: {...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE} as PartialBlock,\n}\n\nexport const HTML_DECORATOR_TAGS: Record<string, string | undefined> = {\n  b: 'strong',\n  strong: 'strong',\n\n  i: 'em',\n  em: 'em',\n\n  u: 'underline',\n  s: 'strike-through',\n  strike: 'strike-through',\n  del: 'strike-through',\n\n  code: 'code',\n}\n\nexport const HTML_LIST_ITEM_TAGS: Record<string, PartialBlock | undefined> = {\n  li: {\n    ...DEFAULT_BLOCK,\n    style: BLOCK_DEFAULT_STYLE,\n    level: 1,\n    listItem: 'bullet',\n  },\n}\n\nexport const ELEMENT_MAP = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_SPAN_TAGS,\n  ...HTML_LIST_CONTAINER_TAGS,\n  ...HTML_LIST_ITEM_TAGS,\n  ...HTML_HEADER_TAGS,\n  ...HTML_MISC_TAGS,\n}\n\nexport const DEFAULT_SUPPORTED_STYLES = uniq(\n  Object.values(ELEMENT_MAP)\n    .filter((tag): tag is PartialBlock => 'style' in tag)\n    .map((tag) => tag.style)\n)\n\nexport const DEFAULT_SUPPORTED_DECORATORS = uniq(Object.values(HTML_DECORATOR_TAGS))\n\nexport const DEFAULT_SUPPORTED_ANNOTATIONS = ['link']\n","// We need this here if run server side\nexport const _XPathResult = {\n  ANY_TYPE: 0,\n  NUMBER_TYPE: 1,\n  STRING_TYPE: 2,\n  BOOLEAN_TYPE: 3,\n  UNORDERED_NODE_ITERATOR_TYPE: 4,\n  ORDERED_NODE_ITERATOR_TYPE: 5,\n  UNORDERED_NODE_SNAPSHOT_TYPE: 6,\n  ORDERED_NODE_SNAPSHOT_TYPE: 7,\n  ANY_UNORDERED_NODE_TYPE: 8,\n  FIRST_ORDERED_NODE_TYPE: 9,\n}\n","import {_XPathResult} from './xpathResult'\n\n// Remove this cruft from the document\nconst unwantedWordDocumentPaths = [\n  '/html/text()',\n  '/html/head/text()',\n  '/html/body/text()',\n  '/html/body/ul/text()',\n  '/html/body/ol/text()',\n  '//comment()',\n  '//style',\n  '//xml',\n  '//script',\n  '//meta',\n  '//link',\n]\n\nexport default (html: string, doc: Document): Document => {\n  // Make sure text directly on the body is wrapped in spans.\n  // This mimics what the browser does before putting html on the clipboard,\n  // when used in a script context with JSDOM\n  const bodyTextNodes = doc.evaluate(\n    '/html/body/text()',\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  )\n\n  for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {\n    const node = bodyTextNodes.snapshotItem(i) as HTMLElement\n    const text = node.textContent || ''\n    if (text.replace(/[^\\S\\n]+$/g, '')) {\n      const newNode = doc.createElement('span')\n      newNode.appendChild(doc.createTextNode(text))\n      node.parentNode?.replaceChild(newNode, node)\n    } else {\n      node.parentNode?.removeChild(node)\n    }\n  }\n\n  const unwantedNodes = doc.evaluate(\n    unwantedWordDocumentPaths.join('|'),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  )\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i)\n    if (!unwanted) {\n      continue\n    }\n    unwanted.parentNode?.removeChild(unwanted)\n  }\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\nconst WORD_HTML_REGEX = /(class=\"?Mso|style=(?:\"|')[^\"]*?\\bmso-|w:WordDocument|<o:\\w+>|<\\/font>)/\n\n// xPaths for elements that will be removed from the document\nconst unwantedPaths = [\n  '//o:p',\n  \"//span[@style='mso-list:Ignore']\",\n  \"//span[@style='mso-list: Ignore']\",\n]\n\n// xPaths for elements that needs to be remapped into other tags\nconst mappedPaths = [\n  \"//p[@class='MsoTocHeading']\",\n  \"//p[@class='MsoTitle']\",\n  \"//p[@class='MsoToaHeading']\",\n  \"//p[@class='MsoSubtitle']\",\n  \"//span[@class='MsoSubtleEmphasis']\",\n  \"//span[@class='MsoIntenseEmphasis']\",\n]\n\n// Which HTML element(s) to map the elements matching mappedPaths into\nconst elementMap: Record<string, string[] | undefined> = {\n  MsoTocHeading: ['h3'],\n  MsoTitle: ['h1'],\n  MsoToaHeading: ['h2'],\n  MsoSubtitle: ['h5'],\n  MsoSubtleEmphasis: ['span', 'em'],\n  MsoIntenseEmphasis: ['span', 'em', 'strong'],\n  // Remove cruft\n}\n\nfunction isWordHtml(html: string) {\n  return WORD_HTML_REGEX.test(html)\n}\n\nexport default (html: string, doc: Document): Document => {\n  if (!isWordHtml(html)) {\n    return doc\n  }\n\n  const unwantedNodes = doc.evaluate(\n    unwantedPaths.join('|'),\n    doc,\n    (prefix) => {\n      if (prefix === 'o') {\n        return 'urn:schemas-microsoft-com:office:office'\n      }\n      return null\n    },\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  )\n\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i)\n    if (unwanted?.parentNode) {\n      unwanted.parentNode.removeChild(unwanted)\n    }\n  }\n\n  // Transform mapped elements into what they should be mapped to\n  const mappedElements = doc.evaluate(\n    mappedPaths.join('|'),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  )\n  for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {\n    const mappedElm = mappedElements.snapshotItem(i) as HTMLElement\n    const tags = elementMap[mappedElm.className]\n    const text = new Text(mappedElm.textContent || '')\n    if (!tags) {\n      continue\n    }\n\n    const parentElement = document.createElement(tags[0])\n    let parent = parentElement\n    let child = parentElement\n    tags.slice(1).forEach((tag) => {\n      child = document.createElement(tag)\n      parent.appendChild(child)\n      parent = child\n    })\n    child.appendChild(text)\n    mappedElm?.parentNode?.replaceChild(parentElement, mappedElm)\n  }\n\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\nfunction isGoogleDocsDocument(el: Element) {\n  if (el.nodeType !== 1) {\n    return false\n  }\n  const id = el.getAttribute('id')\n  return id && id.match(/^docs-internal-guid-/) && el.tagName === 'B'\n}\n\nexport default (html: string, doc: Document): Document => {\n  if (doc.body.firstElementChild && isGoogleDocsDocument(doc.body.firstElementChild)) {\n    // Tag every child with attribute 'is-google-docs' so that the GDocs rule-set can\n    // work exclusivly on these children\n    const childNodes = doc.evaluate(\n      '//*',\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null\n    )\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i) as HTMLElement\n      elm?.setAttribute('data-is-google-docs', 'true')\n    }\n    // Remove that 'b' which Google Docs wraps the HTML content in\n    doc.body.firstElementChild.replaceWith(...Array.from(doc.body.firstElementChild.childNodes))\n    return doc\n  }\n  return doc\n}\n","import preprocessHTML from './html'\nimport preprocessWord from './word'\nimport preprocessGDocs from './gdocs'\n\nexport default [preprocessWord, preprocessGDocs, preprocessHTML]\n","import {ArraySchemaType, Block, isBlock} from '@sanity/types'\nimport {isEqual} from 'lodash'\nimport {DEFAULT_BLOCK} from '../constants'\nimport {resolveJsType} from '../util/resolveJsType'\nimport type {\n  BlockEnabledFeatures,\n  HtmlParser,\n  MinimalBlock,\n  MinimalSpan,\n  PlaceholderAnnotation,\n  PlaceholderDecorator,\n  TypedObject,\n} from '../types'\nimport blockContentTypeFeatures from '../util/blockContentTypeFeatures'\nimport preprocessors from './preprocessors'\n\n/**\n * A utility function to create the options needed for the various rule sets,\n * based on the structure of the blockContentType\n *\n * @param blockContentType - Schema type for array containing _at least_ a block child type\n * @returns\n */\nexport function createRuleOptions(blockContentType: ArraySchemaType): BlockEnabledFeatures {\n  const features = blockContentTypeFeatures(blockContentType)\n  const enabledBlockStyles = features.styles.map((item) => item.value || item.title)\n  const enabledSpanDecorators = features.decorators.map((item) => item.value || item.title)\n  const enabledBlockAnnotations = features.annotations.map((item) => item.value || item.title || '')\n  return {\n    enabledBlockStyles,\n    enabledSpanDecorators,\n    enabledBlockAnnotations,\n  }\n}\n\n/**\n * Utility function that always return a lowerCase version of the element.tagName\n *\n * @param el - Element to get tag name for\n * @returns Lowercase tagName for that element, or undefined if not an element\n */\nexport function tagName(el: HTMLElement | Node | null): string | undefined {\n  if (el && 'tagName' in el) {\n    return el.tagName.toLowerCase()\n  }\n\n  return undefined\n}\n\n// TODO: make this plugin-style\nexport function preprocess(html: string, parseHtml: HtmlParser): Document {\n  const compactHtml = html\n    .trim() // Trim whitespace\n    .replace(/\\s\\s+/g, ' ') // Remove multiple whitespace\n    .replace(/[\\r\\n]/g, ' ') // Remove newlines / carriage returns\n  const doc = parseHtml(compactHtml)\n  preprocessors.forEach((processor) => {\n    processor(html, doc)\n  })\n  return doc\n}\n\n/**\n * A default `parseHtml` function that returns the html using `DOMParser`.\n *\n * @returns HTML Parser based on `DOMParser`\n */\nexport function defaultParseHtml(): HtmlParser {\n  if (resolveJsType(DOMParser) === 'undefined') {\n    throw new Error(\n      'The native `DOMParser` global which the `Html` deserializer uses by ' +\n        'default is not present in this environment. ' +\n        'You must supply the `options.parseHtml` function instead.'\n    )\n  }\n  return (html) => {\n    return new DOMParser().parseFromString(html, 'text/html')\n  }\n}\n\nexport function flattenNestedBlocks(blocks: TypedObject[]): TypedObject[] {\n  let depth = 0\n  const flattened: TypedObject[] = []\n  const traverse = (nodes: TypedObject[]) => {\n    const toRemove: TypedObject[] = []\n    nodes.forEach((node) => {\n      if (depth === 0) {\n        flattened.push(node)\n      }\n      if (isBlock(node)) {\n        if (depth > 0) {\n          toRemove.push(node)\n          flattened.push(node)\n        }\n        depth++\n        traverse(node.children)\n      }\n      if (node._type === '__block') {\n        toRemove.push(node)\n        flattened.push((node as any).block)\n      }\n    })\n    toRemove.forEach((node) => {\n      nodes.splice(nodes.indexOf(node), 1)\n    })\n    depth--\n  }\n  traverse(blocks)\n  return flattened\n}\n\nfunction nextSpan(block: Block, index: number) {\n  const next = block.children[index + 1]\n  return next && next._type === 'span' ? next : null\n}\n\nfunction prevSpan(block: Block, index: number) {\n  const prev = block.children[index - 1]\n  return prev && prev._type === 'span' ? prev : null\n}\n\nfunction isWhiteSpaceChar(text: string) {\n  return ['\\xa0', ' '].includes(text)\n}\n\n/**\n * NOTE: _mutates_ passed blocks!\n *\n * @param blocks - Array of blocks to trim whitespace for\n * @returns\n */\nexport function trimWhitespace(blocks: TypedObject[]): TypedObject[] {\n  blocks.forEach((block) => {\n    if (!isBlock(block)) {\n      return\n    }\n\n    // eslint-disable-next-line complexity\n    block.children.forEach((child, index) => {\n      if (child._type !== 'span') {\n        return\n      }\n      const nextChild = nextSpan(block, index)\n      const prevChild = prevSpan(block, index)\n      if (index === 0) {\n        child.text = child.text.replace(/^[^\\S\\n]+/g, '')\n      }\n      if (index === block.children.length - 1) {\n        child.text = child.text.replace(/[^\\S\\n]+$/g, '')\n      }\n      if (\n        /\\s/.test(child.text.substring(child.text.length - 1)) &&\n        nextChild &&\n        /\\s/.test(nextChild.text.substring(0, 1))\n      ) {\n        child.text = child.text.replace(/[^\\S\\n]+$/g, '')\n      }\n      if (\n        /\\s/.test(child.text.substring(0, 1)) &&\n        prevChild &&\n        /\\s/.test(prevChild.text.substring(prevChild.text.length - 1))\n      ) {\n        child.text = child.text.replace(/^[^\\S\\n]+/g, '')\n      }\n      if (!child.text) {\n        block.children.splice(index, 1)\n      }\n      if (prevChild && isEqual(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text)) {\n        prevChild.text += ' '\n        block.children.splice(index, 1)\n      } else if (\n        nextChild &&\n        isEqual(nextChild.marks, child.marks) &&\n        isWhiteSpaceChar(child.text)\n      ) {\n        nextChild.text = ` ${nextChild.text}`\n        block.children.splice(index, 1)\n      }\n    })\n  })\n\n  return blocks\n}\n\nexport function ensureRootIsBlocks(blocks: TypedObject[]): TypedObject[] {\n  return blocks.reduce((memo, node, i, original) => {\n    if (node._type === 'block') {\n      memo.push(node)\n      return memo\n    }\n\n    if (node._type === '__block') {\n      memo.push((node as any).block)\n      return memo\n    }\n\n    const lastBlock = memo[memo.length - 1]\n    if (i > 0 && !isBlock(original[i - 1]) && isBlock<TypedObject>(lastBlock)) {\n      lastBlock.children.push(node)\n      return memo\n    }\n\n    const block = {\n      ...DEFAULT_BLOCK,\n      children: [node],\n    }\n\n    memo.push(block)\n    return memo\n  }, [] as TypedObject[])\n}\n\nexport function isNodeList(node: unknown): node is NodeList {\n  return Object.prototype.toString.call(node) == '[object NodeList]'\n}\n\nexport function isMinimalSpan(node: TypedObject): node is MinimalSpan {\n  return node._type === 'span'\n}\n\nexport function isMinimalBlock(node: TypedObject): node is MinimalBlock {\n  return node._type === 'block'\n}\n\nexport function isPlaceholderDecorator(node: TypedObject): node is PlaceholderDecorator {\n  return node._type === '__decorator'\n}\n\nexport function isPlaceholderAnnotation(node: TypedObject): node is PlaceholderAnnotation {\n  return node._type === '__annotation'\n}\n\nexport function isElement(node: Node): node is Element {\n  return node.nodeType === 1\n}\n","import type {ArraySchemaType} from '@sanity/types'\nimport {randomKey} from '../../util/randomKey'\nimport {isElement, tagName} from '../helpers'\nimport {\n  DEFAULT_BLOCK,\n  DEFAULT_SPAN,\n  HTML_BLOCK_TAGS,\n  HTML_HEADER_TAGS,\n  HTML_SPAN_TAGS,\n  HTML_LIST_CONTAINER_TAGS,\n  HTML_LIST_ITEM_TAGS,\n  HTML_DECORATOR_TAGS,\n  PartialBlock,\n} from '../../constants'\nimport {BlockEnabledFeatures, DeserializerRule} from '../../types'\n\nexport function resolveListItem(listNodeTagName: string): string {\n  let listStyle\n  switch (listNodeTagName) {\n    case 'ul':\n      listStyle = 'bullet'\n      break\n    case 'ol':\n      listStyle = 'number'\n      break\n    default:\n      listStyle = 'bullet'\n  }\n  return listStyle\n}\n\nexport default function createHTMLRules(\n  blockContentType: ArraySchemaType,\n  options: BlockEnabledFeatures\n): DeserializerRule[] {\n  return [\n    // Text nodes\n    {\n      deserialize(el) {\n        const isValidWhiteSpace =\n          el.nodeType === 3 &&\n          (el.textContent || '').replace(/[\\r\\n]/g, ' ').replace(/\\s\\s+/g, ' ') === ' ' &&\n          el.nextSibling &&\n          el.nextSibling.nodeType !== 3 &&\n          el.previousSibling &&\n          el.previousSibling.nodeType !== 3\n        const isValidText =\n          (isValidWhiteSpace || el.textContent !== ' ') && tagName(el.parentNode) !== 'body'\n        if (el.nodeName === '#text' && isValidText) {\n          return {\n            ...DEFAULT_SPAN,\n            marks: [],\n            text: (el.textContent || '').replace(/\\s\\s+/g, ' '),\n          }\n        }\n        return undefined\n      },\n    }, // Blockquote element\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== 'blockquote') {\n          return undefined\n        }\n        const blocks: Record<string, PartialBlock | undefined> = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS,\n        }\n        delete blocks.blockquote\n\n        const children: HTMLElement[] = []\n        el.childNodes.forEach((node, index) => {\n          if (\n            node.nodeType === 1 &&\n            Object.keys(blocks).includes((node as Element).localName.toLowerCase())\n          ) {\n            if (!el.ownerDocument) {\n              return\n            }\n\n            const span = el.ownerDocument.createElement('span')\n            span.appendChild(el.ownerDocument.createTextNode('\\r'))\n            node.childNodes.forEach((cn) => {\n              span.appendChild(cn.cloneNode(true))\n            })\n            if (index !== el.childNodes.length) {\n              span.appendChild(el.ownerDocument.createTextNode('\\r'))\n            }\n            children.push(span)\n          } else {\n            children.push(node as HTMLElement)\n          }\n        })\n\n        return {\n          _type: 'block',\n          style: 'blockquote',\n          markDefs: [],\n          children: next(children),\n        }\n      },\n    }, // Block elements\n    {\n      deserialize(el, next) {\n        const blocks: Record<string, PartialBlock | undefined> = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS,\n        }\n        const tag = tagName(el)\n        let block = tag ? blocks[tag] : undefined\n        if (!block) {\n          return undefined\n        }\n        // Don't add blocks into list items\n        if (el.parentNode && tagName(el) === 'li') {\n          return next(el.childNodes)\n        }\n        // If style is not supported, return a defaultBlockType\n        if (!options.enabledBlockStyles.includes(block.style)) {\n          block = DEFAULT_BLOCK\n        }\n        return {\n          ...block,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Ignore span tags\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n        if (!tag || !(tag in HTML_SPAN_TAGS)) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Ignore div tags\n    {\n      deserialize(el, next) {\n        const div = tagName(el) === 'div'\n        if (!div) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Ignore list containers\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n        if (!tag || !(tag in HTML_LIST_CONTAINER_TAGS)) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Deal with br's\n    {\n      deserialize(el) {\n        if (tagName(el) === 'br') {\n          return {\n            ...DEFAULT_SPAN,\n            text: '\\n',\n          }\n        }\n        return undefined\n      },\n    }, // Deal with list items\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n        const listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : undefined\n        const parentTag = tagName(el.parentNode) || ''\n        if (!listItem || !el.parentNode || !HTML_LIST_CONTAINER_TAGS[parentTag]) {\n          return undefined\n        }\n\n        listItem.listItem = resolveListItem(parentTag)\n        return {\n          ...listItem,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Deal with decorators\n    {\n      deserialize(el, next) {\n        const decorator = HTML_DECORATOR_TAGS[tagName(el) || '']\n        if (!decorator || !options.enabledSpanDecorators.includes(decorator)) {\n          return undefined\n        }\n        return {\n          _type: '__decorator',\n          name: decorator,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Special case for hyperlinks, add annotation (if allowed by schema),\n    // If not supported just write out the link text and href in plain text.\n    {\n      deserialize(el, next) {\n        if (tagName(el) != 'a') {\n          return undefined\n        }\n        const linkEnabled = options.enabledBlockAnnotations.includes('link')\n        const href = isElement(el) && el.getAttribute('href')\n        if (!href) {\n          return next(el.childNodes)\n        }\n        let markDef\n        if (linkEnabled) {\n          markDef = {\n            _key: randomKey(12),\n            _type: 'link',\n            href: href,\n          }\n          return {\n            _type: '__annotation',\n            markDef: markDef,\n            children: next(el.childNodes),\n          }\n        }\n        return el.appendChild(el.ownerDocument.createTextNode(` (${href})`)) && next(el.childNodes)\n      },\n    },\n  ]\n}\n","import type {ArraySchemaType} from '@sanity/types'\nimport type {BlockEnabledFeatures, DeserializerRule} from '../../types'\nimport {\n  BLOCK_DEFAULT_STYLE,\n  DEFAULT_BLOCK,\n  DEFAULT_SPAN,\n  HTML_BLOCK_TAGS,\n  HTML_HEADER_TAGS,\n  HTML_LIST_CONTAINER_TAGS,\n} from '../../constants'\nimport {isElement, tagName} from '../helpers'\n\nconst LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS)\n\n// font-style:italic seems like the most important rule for italic / emphasis in their html\nfunction isEmphasis(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-style:italic/.test(style || '')\n}\n\n// font-weight:700 seems like the most important rule for bold in their html\nfunction isStrong(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-weight:700/.test(style || '')\n}\n\n// Check for attribute given by the gdocs preprocessor\nfunction isGoogleDocs(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-google-docs'))\n}\n\nfunction getListItemStyle(el: Node): 'bullet' | 'number' | undefined {\n  const parentTag = tagName(el.parentNode)\n  if (parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)) {\n    return undefined\n  }\n  return tagName(el.parentNode) === 'ul' ? 'bullet' : 'number'\n}\n\nfunction getListItemLevel(el: Node): number {\n  let level = 0\n  if (tagName(el) === 'li') {\n    let parentNode = el.parentNode\n    while (parentNode) {\n      const parentTag = tagName(parentNode)\n      if (parentTag && LIST_CONTAINER_TAGS.includes(parentTag)) {\n        level++\n      }\n      parentNode = parentNode.parentNode\n    }\n  } else {\n    level = 1\n  }\n  return level\n}\n\nconst blocks: Record<string, {style: string} | undefined> = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_HEADER_TAGS,\n}\n\nfunction getBlockStyle(el: Node, enabledBlockStyles: string[]): string {\n  const childTag = tagName(el.firstChild)\n  const block = childTag && blocks[childTag]\n  if (!block) {\n    return BLOCK_DEFAULT_STYLE\n  }\n  if (!enabledBlockStyles.includes(block.style)) {\n    return BLOCK_DEFAULT_STYLE\n  }\n  return block.style\n}\n\nexport default function createGDocsRules(\n  _blockContentType: ArraySchemaType,\n  options: BlockEnabledFeatures\n): DeserializerRule[] {\n  return [\n    {\n      deserialize(el) {\n        if (isElement(el) && tagName(el) === 'span' && isGoogleDocs(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as string[],\n            text: (el as HTMLElement).innerText,\n          }\n          if (isStrong(el)) {\n            span.marks.push('strong')\n          }\n          if (isEmphasis(el)) {\n            span.marks.push('em')\n          }\n          return span\n        }\n        return undefined\n      },\n    },\n    {\n      deserialize(el, next) {\n        if (tagName(el) === 'li' && isGoogleDocs(el)) {\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: getBlockStyle(el, options.enabledBlockStyles),\n            children: next(el.firstChild?.childNodes || []),\n          }\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import type {DeserializerRule} from '../../types'\nimport {DEFAULT_BLOCK, BLOCK_DEFAULT_STYLE} from '../../constants'\nimport {isElement, tagName} from '../helpers'\n\nfunction getListItemStyle(el: Node): string | undefined {\n  const style = isElement(el) && el.getAttribute('style')\n  if (!style) {\n    return undefined\n  }\n\n  if (!style.match(/lfo\\d+/)) {\n    return undefined\n  }\n\n  return style.match('lfo1') ? 'bullet' : 'number'\n}\n\nfunction getListItemLevel(el: Node): number | undefined {\n  const style = isElement(el) && el.getAttribute('style')\n  if (!style) {\n    return undefined\n  }\n\n  const levelMatch = style.match(/level\\d+/)\n  if (!levelMatch) {\n    return undefined\n  }\n\n  const [level] = levelMatch[0].match(/\\d/) || []\n  const levelNum = level ? parseInt(level, 10) : 1\n  return levelNum || 1\n}\n\nfunction isWordListElement(el: Node): boolean {\n  return isElement(el) && el.className\n    ? el.className === 'MsoListParagraphCxSpFirst' ||\n        el.className === 'MsoListParagraphCxSpMiddle' ||\n        el.className === 'MsoListParagraphCxSpLast'\n    : false\n}\n\nexport default function createWordRules(): DeserializerRule[] {\n  return [\n    {\n      deserialize(el, next) {\n        if (tagName(el) === 'p' && isWordListElement(el)) {\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: BLOCK_DEFAULT_STYLE,\n            children: next(el.childNodes),\n          }\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import type {ArraySchemaType} from '@sanity/types'\nimport type {BlockEnabledFeatures, DeserializerRule} from '../../types'\nimport createHTMLRules from './html'\nimport createGDocsRules from './gdocs'\nimport createWordRules from './word'\n\nexport function createRules(\n  blockContentType: ArraySchemaType,\n  options: BlockEnabledFeatures\n): DeserializerRule[] {\n  return [\n    ...createWordRules(),\n    ...createGDocsRules(blockContentType, options),\n    ...createHTMLRules(blockContentType, options),\n  ]\n}\n","import type {ArraySchemaType, Block, MarkDefinition} from '@sanity/types'\nimport {flatten} from 'lodash'\nimport {findBlockType} from '../util/findBlockType'\nimport {resolveJsType} from '../util/resolveJsType'\nimport type {\n  ArbitraryTypedObject,\n  DeserializerRule,\n  HtmlDeserializerOptions,\n  PlaceholderAnnotation,\n  PlaceholderDecorator,\n  TypedObject,\n} from '../types'\nimport {createRules} from './rules'\nimport {\n  createRuleOptions,\n  defaultParseHtml,\n  ensureRootIsBlocks,\n  flattenNestedBlocks,\n  trimWhitespace,\n  preprocess,\n  tagName,\n  isNodeList,\n  isMinimalSpan,\n  isPlaceholderDecorator,\n  isPlaceholderAnnotation,\n  isMinimalBlock,\n} from './helpers'\n\n/**\n * HTML Deserializer\n *\n */\nexport default class HtmlDeserializer {\n  blockContentType: ArraySchemaType\n  rules: DeserializerRule[]\n  parseHtml: (html: string) => HTMLElement\n  _markDefs: MarkDefinition[] = []\n\n  /**\n   * Create a new serializer respecting a Sanity block content type's schema\n   *\n   * @param blockContentType - Schema type for array containing _at least_ a block child type\n   * @param options - Options for the deserialization process\n   */\n  constructor(blockContentType: ArraySchemaType, options: HtmlDeserializerOptions = {}) {\n    const {rules = []} = options\n    if (!blockContentType) {\n      throw new Error(\"Parameter 'blockContentType' is required\")\n    }\n    const standardRules = createRules(blockContentType, createRuleOptions(blockContentType))\n    this.rules = [...rules, ...standardRules]\n    const parseHtml = options.parseHtml || defaultParseHtml()\n    this.blockContentType = blockContentType\n    this.parseHtml = (html) => {\n      const doc = preprocess(html, parseHtml)\n      return doc.body\n    }\n  }\n\n  /**\n   * Deserialize HTML.\n   *\n   * @param html - The HTML to deserialize, as a string\n   * @returns Array of blocks - either portable text blocks or other allowed blocks\n   */\n  deserialize = (html: string): TypedObject[] => {\n    this._markDefs = []\n    const {parseHtml} = this\n    const fragment = parseHtml(html)\n    const children = Array.from(fragment.childNodes) as HTMLElement[]\n    // Ensure that there are no blocks within blocks, and trim whitespace\n    const blocks = trimWhitespace(\n      flattenNestedBlocks(ensureRootIsBlocks(this.deserializeElements(children)))\n    )\n\n    if (this._markDefs.length > 0) {\n      blocks\n        .filter((block): block is Block => block._type === 'block')\n        .forEach((block) => {\n          block.markDefs = block.markDefs || []\n          block.markDefs = block.markDefs.concat(\n            this._markDefs.filter((def) => {\n              return flatten(block.children.map((child) => child.marks || [])).includes(def._key)\n            })\n          )\n        })\n    }\n\n    // Set back the potentially hoisted block type\n    const type = this.blockContentType.of.find(findBlockType)\n    if (!type) {\n      return blocks\n    }\n\n    return blocks.map((block) => {\n      if (block._type === 'block') {\n        block._type = type.name\n      }\n      return block\n    })\n  }\n\n  /**\n   * Deserialize an array of DOM elements.\n   *\n   * @param elements - Array of DOM elements to deserialize\n   * @returns\n   */\n  deserializeElements = (elements: Node[] = []): TypedObject[] => {\n    let nodes: TypedObject[] = []\n    elements.forEach((element) => {\n      nodes = nodes.concat(this.deserializeElement(element))\n    })\n    return nodes\n  }\n\n  /**\n   * Deserialize a DOM element\n   *\n   * @param element - Deserialize a DOM element\n   * @returns\n   */\n  deserializeElement = (element: Node): TypedObject | TypedObject[] => {\n    const next = (elements: Node | Node[] | NodeList): TypedObject | TypedObject[] | undefined => {\n      if (isNodeList(elements)) {\n        return this.deserializeElements(Array.from(elements))\n      }\n\n      if (Array.isArray(elements)) {\n        return this.deserializeElements(elements)\n      }\n\n      if (!elements) {\n        return undefined\n      }\n\n      return this.deserializeElement(elements)\n    }\n\n    const block = (props: ArbitraryTypedObject) => {\n      return {\n        _type: '__block',\n        block: props,\n      }\n    }\n\n    let node\n    for (let i = 0; i < this.rules.length; i++) {\n      const rule = this.rules[i]\n      if (!rule.deserialize) {\n        continue\n      }\n\n      const ret = rule.deserialize(element, next, block)\n      const type = resolveJsType(ret)\n\n      if (type !== 'array' && type !== 'object' && type !== 'null' && type !== 'undefined') {\n        throw new Error(`A rule returned an invalid deserialized representation: \"${node}\".`)\n      }\n\n      if (ret === undefined) {\n        continue\n      } else if (ret === null) {\n        throw new Error('Deserializer rule returned `null`')\n      } else if (Array.isArray(ret)) {\n        node = ret\n      } else if (isPlaceholderDecorator(ret)) {\n        node = this.deserializeDecorator(ret)\n      } else if (isPlaceholderAnnotation(ret)) {\n        node = this.deserializeAnnotation(ret)\n      } else {\n        node = ret\n      }\n\n      // Set list level on list item\n      if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && 'listItem' in ret) {\n        let parent = element.parentNode?.parentNode\n        while (parent && tagName(parent) === 'li') {\n          parent = parent.parentNode?.parentNode\n          ret.level = ret.level ? ret.level + 1 : 1\n        }\n      }\n\n      // Set newlines on spans orginating from a block element within a blockquote\n      if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && ret.style === 'blockquote') {\n        ret.children.forEach((child, index) => {\n          if (isMinimalSpan(child) && child.text === '\\r') {\n            child.text = '\\n\\n'\n            if (index === 0 || index === ret.children.length - 1) {\n              ret.children.splice(index, 1)\n            }\n          }\n        })\n      }\n      break\n    }\n\n    return node || next(element.childNodes) || []\n  }\n\n  /**\n   * Deserialize a `__decorator` type\n   * (an internal made up type to process decorators exclusively)\n   *\n   * @param decorator -\n   * @returns array of ...\n   */\n  deserializeDecorator = (decorator: PlaceholderDecorator): TypedObject[] => {\n    const {name} = decorator\n    const applyDecorator = (node: TypedObject) => {\n      if (isPlaceholderDecorator(node)) {\n        return this.deserializeDecorator(node)\n      } else if (isMinimalSpan(node)) {\n        node.marks = node.marks || []\n        if (node.text.trim()) {\n          // Only apply marks if this is an actual text\n          node.marks.unshift(name)\n        }\n      } else if ('children' in node && Array.isArray((node as Block).children)) {\n        const block = node as any\n        block.children = block.children.map(applyDecorator)\n      }\n      return node\n    }\n    return decorator.children.reduce((children, node) => {\n      const ret = applyDecorator(node)\n      if (Array.isArray(ret)) {\n        return children.concat(ret)\n      }\n      children.push(ret)\n      return children\n    }, [] as TypedObject[])\n  }\n\n  /**\n   * Deserialize a `__annotation` object.\n   * (an internal made up type to process annotations exclusively)\n   *\n   * @param annotation -\n   * @returns Array of...\n   */\n  deserializeAnnotation = (annotation: PlaceholderAnnotation): TypedObject[] => {\n    const {markDef} = annotation\n    this._markDefs.push(markDef)\n    const applyAnnotation = (node: TypedObject) => {\n      if (isPlaceholderAnnotation(node)) {\n        return this.deserializeAnnotation(node)\n      } else if (isMinimalSpan(node)) {\n        node.marks = node.marks || []\n        if (node.text.trim()) {\n          // Only apply marks if this is an actual text\n          node.marks.unshift(markDef._key)\n        }\n      } else if ('children' in node && Array.isArray((node as Block).children)) {\n        const block = node as any\n        block.children = block.children.map(applyAnnotation)\n      }\n      return node\n    }\n    return annotation.children.reduce((children, node) => {\n      const ret = applyAnnotation(node)\n      if (Array.isArray(ret)) {\n        return children.concat(ret)\n      }\n      children.push(ret)\n      return children\n    }, [] as TypedObject[])\n  }\n}\n","import {Block, Span, isSpan} from '@sanity/types'\nimport {isEqual} from 'lodash'\nimport {TypedObject} from '../types'\nimport {randomKey} from './randomKey'\n\n/**\n * Block normalization options\n *\n * @public\n */\nexport interface BlockNormalizationOptions {\n  /**\n   * Decorator names that are allowed within portable text blocks, eg `em`, `strong`\n   */\n  allowedDecorators?: string[]\n\n  /**\n   * Name of the portable text block type, if not `block`\n   */\n  blockTypeName?: string\n}\n\n/**\n * Normalizes a block by ensuring it has a `_key` property. If the block is a\n * portable text block, additional normalization is applied:\n *\n * - Ensures it has `children` and `markDefs` properties\n * - Ensures it has at least one child (adds an empty span if empty)\n * - Joins sibling spans that has the same marks\n * - Removes decorators that are not allowed according to the schema\n * - Removes marks that have no annotation definition\n *\n * @param node - The block to normalize\n * @param options - Options for normalization process. See {@link BlockNormalizationOptions}\n * @returns Normalized block\n * @public\n */\nexport function normalizeBlock(\n  node: TypedObject,\n  options: BlockNormalizationOptions = {}\n): Omit<TypedObject | Block<TypedObject | Span>, '_key'> & {_key: string} {\n  if (node._type !== (options.blockTypeName || 'block')) {\n    return '_key' in node ? (node as TypedObject & {_key: string}) : {...node, _key: randomKey(12)}\n  }\n\n  const block: Omit<Block<TypedObject | Span>, 'style'> = {\n    _key: randomKey(12),\n    children: [],\n    markDefs: [],\n    ...node,\n  }\n\n  const lastChild = block.children[block.children.length - 1]\n  if (!lastChild) {\n    // A block must at least have an empty span type child\n    block.children = [\n      {\n        _type: 'span',\n        _key: `${block._key}${0}`,\n        text: '',\n        marks: [],\n      },\n    ]\n    return block\n  }\n\n  const usedMarkDefs: string[] = []\n  const allowedDecorators =\n    options.allowedDecorators && Array.isArray(options.allowedDecorators)\n      ? options.allowedDecorators\n      : false\n\n  block.children = block.children\n    .reduce((acc, child) => {\n      const previousChild = acc[acc.length - 1]\n      if (\n        previousChild &&\n        isSpan(child) &&\n        isSpan(previousChild) &&\n        isEqual(previousChild.marks, child.marks)\n      ) {\n        if (lastChild && lastChild === child && child.text === '' && block.children.length > 1) {\n          return acc\n        }\n\n        previousChild.text += child.text\n        return acc\n      }\n      acc.push(child)\n      return acc\n    }, [] as (TypedObject | Span)[])\n    .map((child, index) => {\n      if (!child) {\n        throw new Error('missing child')\n      }\n\n      child._key = `${block._key}${index}`\n      if (isSpan(child)) {\n        if (!child.marks) {\n          child.marks = []\n        } else if (allowedDecorators) {\n          child.marks = child.marks.filter((mark) => {\n            const isAllowed = allowedDecorators.includes(mark)\n            const isUsed = block.markDefs.some((def) => def._key === mark)\n            return isAllowed || isUsed\n          })\n        }\n\n        usedMarkDefs.push(...child.marks)\n      }\n\n      return child\n    })\n\n  // Remove leftover (unused) markDefs\n  block.markDefs = block.markDefs.filter((markDef) => usedMarkDefs.includes(markDef._key))\n  return block\n}\n","import type {ArraySchemaType, Block, Span} from '@sanity/types'\nimport blockContentTypeFeatures from './util/blockContentTypeFeatures'\nimport HtmlDeserializer from './HtmlDeserializer'\nimport {normalizeBlock} from './util/normalizeBlock'\nimport {BlockContentFeatures, HtmlDeserializerOptions, TypedObject} from './types'\n\n/**\n * Convert HTML to blocks respecting the block content type's schema\n *\n * @param html - The HTML to convert to blocks\n * @param blockContentType - A compiled version of the schema type for the block content\n * @param options - Options for deserializing HTML to blocks\n * @returns Array of blocks\n * @public\n */\nexport function htmlToBlocks(\n  html: string,\n  blockContentType: ArraySchemaType,\n  options: HtmlDeserializerOptions = {}\n): (TypedObject | Block<TypedObject | Span>)[] {\n  const deserializer = new HtmlDeserializer(blockContentType, options)\n  return deserializer.deserialize(html).map((block) => normalizeBlock(block))\n}\n\n/**\n * Normalize and extract features of an schema type containing a block type\n *\n * @param blockContentType - Schema type for the block type\n * @returns Returns the featureset of a compiled block content type.\n * @public\n */\nexport function getBlockContentFeatures(blockContentType: ArraySchemaType): BlockContentFeatures {\n  return blockContentTypeFeatures(blockContentType)\n}\n\nexport {normalizeBlock}\nexport {randomKey} from './util/randomKey'\nexport type {TypedObject, HtmlDeserializerOptions, BlockContentFeatures}\nexport type {\n  ResolvedAnnotationType,\n  DeserializerRule,\n  HtmlParser,\n  ArbitraryTypedObject,\n  BlockEditorSchemaProps,\n} from './types'\nexport type {BlockNormalizationOptions} from './util/normalizeBlock'\n"],"names":["isRecord$1","value","isBlock","_type","style","Array","isArray","children","markDefs","isSpan","text","marks","isRecord","isObjectSchemaType","type","jsonType","isArraySchemaType","isTitledListValue","item","isSpanSchemaType","annotations","decorators","isBlockSchemaType","fields","maybeSpanChildren","maybeStyle","maybeList","isBlockChildrenObjectField","isStyleObjectField","isListObjectField","field","name","of","some","findBlockType","blockContentFeatures","blockContentType","_a","_b","Error","blockType","find","ofType","spanType","member","inlineObjectTypes","filter","inlineType","blockObjectTypes","memberType","styles","resolveEnabledStyles","resolveEnabledDecorators","resolveEnabledAnnotationTypes","lists","resolveEnabledListItems","types","block","span","inlineObjects","blockObjects","styleField","textStyles","getTitledListValuesFromEnumListOptions","options","length","map","annotation","blockEditor","title","icon","listField","listItems","list","toString","Object","prototype","resolveJsType","val","call","nodeType","whatwgRNG","rnds8","Uint8Array","getRandomValues","byteToHex","i","substring","randomKey","reduce","str","n","slice","BLOCK_DEFAULT_STYLE","DEFAULT_BLOCK","freeze","DEFAULT_SPAN","HTML_BLOCK_TAGS","p","blockquote","HTML_SPAN_TAGS","object","HTML_LIST_CONTAINER_TAGS","ol","ul","HTML_HEADER_TAGS","h1","h2","h3","h4","h5","h6","HTML_MISC_TAGS","br","HTML_DECORATOR_TAGS","b","strong","em","u","s","strike","del","code","HTML_LIST_ITEM_TAGS","li","level","listItem","ELEMENT_MAP","uniq","values","tag","_XPathResult","ANY_TYPE","NUMBER_TYPE","STRING_TYPE","BOOLEAN_TYPE","UNORDERED_NODE_ITERATOR_TYPE","ORDERED_NODE_ITERATOR_TYPE","UNORDERED_NODE_SNAPSHOT_TYPE","ORDERED_NODE_SNAPSHOT_TYPE","ANY_UNORDERED_NODE_TYPE","FIRST_ORDERED_NODE_TYPE","unwantedWordDocumentPaths","preprocessHTML","html","doc","_c","bodyTextNodes","evaluate","snapshotLength","node","snapshotItem","textContent","replace","newNode","createElement","appendChild","createTextNode","parentNode","replaceChild","removeChild","unwantedNodes","join","unwanted","WORD_HTML_REGEX","unwantedPaths","mappedPaths","elementMap","MsoTocHeading","MsoTitle","MsoToaHeading","MsoSubtitle","MsoSubtleEmphasis","MsoIntenseEmphasis","isWordHtml","test","preprocessWord","prefix","mappedElements","mappedElm","tags","className","Text","parentElement","document","parent","child","forEach","isGoogleDocsDocument","el","id","getAttribute","match","tagName","preprocessGDocs","body","firstElementChild","childNodes","elm","setAttribute","replaceWith","from","preprocessors","createRuleOptions","features","blockContentTypeFeatures","enabledBlockStyles","enabledSpanDecorators","enabledBlockAnnotations","toLowerCase","preprocess","parseHtml","compactHtml","trim","processor","defaultParseHtml","DOMParser","parseFromString","flattenNestedBlocks","blocks","depth","flattened","traverse","nodes","toRemove","push","splice","indexOf","nextSpan","index","next","prevSpan","prev","isWhiteSpaceChar","includes","trimWhitespace","nextChild","prevChild","isEqual","ensureRootIsBlocks","memo","original","lastBlock","isNodeList","isMinimalSpan","isMinimalBlock","isPlaceholderDecorator","isPlaceholderAnnotation","isElement","resolveListItem","listNodeTagName","listStyle","createHTMLRules","deserialize","isValidWhiteSpace","nextSibling","previousSibling","isValidText","nodeName","keys","localName","ownerDocument","cn","cloneNode","div","parentTag","decorator","linkEnabled","href","markDef","_key","LIST_CONTAINER_TAGS","isEmphasis","isStrong","isGoogleDocs","Boolean","getListItemStyle","getListItemLevel","getBlockStyle","childTag","firstChild","createGDocsRules","_blockContentType","innerText","levelMatch","levelNum","parseInt","isWordListElement","createWordRules","createRules","HtmlDeserializer","constructor","_markDefs","fragment","deserializeElements","concat","def","flatten","elements","element","deserializeElement","props","rules","rule","ret","deserializeDecorator","deserializeAnnotation","applyDecorator","unshift","applyAnnotation","standardRules","normalizeBlock","blockTypeName","lastChild","usedMarkDefs","allowedDecorators","acc","previousChild","mark","isAllowed","isUsed","htmlToBlocks","deserializer","getBlockContentFeatures"],"mappings":"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"}