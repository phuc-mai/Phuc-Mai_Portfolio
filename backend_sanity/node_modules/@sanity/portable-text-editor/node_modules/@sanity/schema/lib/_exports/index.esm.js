const _excluded = ["name", "fieldset", "group"],
  _excluded2 = ["name"],
  _excluded3 = ["name"],
  _excluded4 = ["name", "fieldset"],
  _excluded5 = ["name", "fieldset"],
  _excluded6 = ["marks", "styles", "lists", "of"],
  _excluded7 = ["name"],
  _excluded8 = ["name"];
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
import { pick, omit, omitBy, isUndefined, capitalize, startCase, isPlainObject, toPath, uniqBy, keyBy, castArray, flatMap } from 'lodash';
import arrify from 'arrify';
const DEFAULT_OVERRIDEABLE_FIELDS = ["jsonType", "type", "name", "title", "description", "options", "fieldsets", "validation", "readOnly", "hidden", "components", "diffComponent", "initialValue"];
const OVERRIDABLE_FIELDS$e = [...DEFAULT_OVERRIDEABLE_FIELDS];
const ANY_CORE = {
  name: "any",
  type: null,
  jsonType: "any"
};
const AnyType = {
  get() {
    return ANY_CORE;
  },
  extend(subTypeDef, extendMember) {
    const parsed = Object.assign(pick(ANY_CORE, OVERRIDABLE_FIELDS$e), subTypeDef, {
      type: ANY_CORE,
      of: subTypeDef.of.map(fieldDef => {
        return {
          name: fieldDef.name,
          type: extendMember(omit(fieldDef, "name"))
        };
      })
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.of) {
            throw new Error('Cannot override `of` property of subtypes of "array"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$e), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var primitivePreview = {
  prepare: val => ({
    title: String(val)
  })
};
const OVERRIDABLE_FIELDS$d = [...DEFAULT_OVERRIDEABLE_FIELDS];
const STRING_CORE = {
  name: "string",
  title: "String",
  type: null,
  jsonType: "string"
};
const StringType = {
  get() {
    return STRING_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign(pick(STRING_CORE, OVERRIDABLE_FIELDS$d), subTypeDef, {
      type: STRING_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$d), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const OVERRIDABLE_FIELDS$c = [...DEFAULT_OVERRIDEABLE_FIELDS, "rows"];
const TEXT_CORE = {
  name: "text",
  title: "Text",
  type: null,
  jsonType: "string"
};
const TextType = {
  get() {
    return TEXT_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign(pick(TEXT_CORE, OVERRIDABLE_FIELDS$c), subTypeDef, {
      type: TEXT_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$c), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const OVERRIDABLE_FIELDS$b = [...DEFAULT_OVERRIDEABLE_FIELDS];
const DATETIME_CORE = {
  name: "datetime",
  title: "Datetime",
  type: null,
  jsonType: "string"
};
const DateTimeType = {
  get() {
    return DATETIME_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign(pick(DATETIME_CORE, OVERRIDABLE_FIELDS$b), subTypeDef, {
      type: DATETIME_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$b), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const OVERRIDABLE_FIELDS$a = [...DEFAULT_OVERRIDEABLE_FIELDS];
const DATE_CORE = {
  name: "date",
  title: "Datetime",
  type: null,
  jsonType: "string"
};
const DateType = {
  get() {
    return DATE_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign(pick(DATE_CORE, OVERRIDABLE_FIELDS$a), subTypeDef, {
      type: DATE_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$a), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const OVERRIDABLE_FIELDS$9 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const BOOLEAN_CORE = {
  name: "boolean",
  title: "Boolean",
  type: null,
  jsonType: "boolean"
};
const BooleanType = {
  get() {
    return BOOLEAN_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign(pick(BOOLEAN_CORE, OVERRIDABLE_FIELDS$9), subTypeDef, {
      type: BOOLEAN_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$9), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const OVERRIDABLE_FIELDS$8 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const URL_CORE = {
  name: "url",
  title: "Url",
  type: null,
  jsonType: "string"
};
const UrlType = {
  get() {
    return URL_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign(pick(URL_CORE, OVERRIDABLE_FIELDS$8), subTypeDef, {
      type: URL_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$8), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const OVERRIDABLE_FIELDS$7 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const EMAIL_CORE = {
  name: "email",
  title: "Email",
  type: null,
  jsonType: "string"
};
const EmailType = {
  get() {
    return EMAIL_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign(pick(EMAIL_CORE, OVERRIDABLE_FIELDS$7), subTypeDef, {
      type: EMAIL_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$7), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const OVERRIDABLE_FIELDS$6 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const NUMBER_CORE = {
  name: "number",
  title: "Number",
  type: null,
  jsonType: "number"
};
const NumberType = {
  get() {
    return NUMBER_CORE;
  },
  extend(subTypeDef) {
    const parsed = Object.assign(pick(NUMBER_CORE, OVERRIDABLE_FIELDS$6), subTypeDef, {
      type: NUMBER_CORE,
      preview: primitivePreview
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$6), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
function lazyGetter(target, key, getter) {
  let config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  Object.defineProperty(target, key, {
    configurable: true,
    enumerable: config.enumerable !== false,
    get() {
      const val = getter();
      Object.defineProperty(target, key, {
        value: val,
        writable: Boolean(config.writable),
        configurable: false
      });
      return val;
    }
  });
  return target;
}
function isEmpty(object) {
  for (const key in object) {
    if (object.hasOwnProperty(key)) {
      return false;
    }
  }
  return true;
}
function _stringify(value, options, depth) {
  if (depth > options.maxDepth) {
    return "...";
  }
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return "[empty]";
    }
    const capLength = Math.max(value.length - options.maxBreadth);
    const asString2 = value.slice(0, options.maxBreadth).map((item, index) => _stringify(item, options, depth + 1)).concat(capLength > 0 ? "\u2026+".concat(capLength) : []).join(", ");
    return depth === 0 ? asString2 : "[".concat(asString2, "]");
  }
  if (typeof value === "object" && value !== null) {
    const keys = Object.keys(value).filter(key => !options.ignoreKeys.includes(key) && typeof value[key] !== "undefined");
    if (isEmpty(pick(value, keys))) {
      return "{empty}";
    }
    const asString2 = keys.slice(0, options.maxBreadth).map(key => "".concat(key, ": ").concat(_stringify(value[key], options, depth + 1))).join(", ");
    return depth === 0 ? asString2 : "{".concat(asString2, "}");
  }
  const asString = String(value);
  return asString === "" ? '""' : asString;
}
function stringify(value) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const opts = {
    maxDepth: "maxDepth" in options ? options.maxDepth : 2,
    maxBreadth: "maxBreadth" in options ? options.maxBreadth : 2,
    ignoreKeys: "ignoreKeys" in options ? options.ignoreKeys : []
  };
  return _stringify(value, opts, 0);
}
const OPTIONS = {
  maxEntries: 2,
  maxDepth: 2,
  maxBreadth: 2,
  ignoreKeys: ["_id", "_type", "_key", "_ref"]
};
function createFallbackPrepare(fieldNames) {
  return value => ({
    title: stringify(pick(value, fieldNames), OPTIONS)
  });
}
function isBlockField(field) {
  return field.type === "array" && field.of && field.of.some(member => member.type === "block");
}
const TITLE_CANDIDATES = ["title", "name", "label", "heading", "header", "caption"];
const DESCRIPTION_CANDIDATES = ["description", ...TITLE_CANDIDATES];
function fieldHasReferenceTo(fieldDef, refType) {
  return arrify(fieldDef.to || []).some(memberTypeDef => memberTypeDef.type === refType);
}
function isImageAssetField(fieldDef) {
  return fieldHasReferenceTo(fieldDef, "sanity.imageAsset");
}
function resolveImageAssetPath(typeDef) {
  const fields = typeDef.fields || [];
  const imageAssetField = fields.find(isImageAssetField);
  if (imageAssetField) {
    return imageAssetField.name;
  }
  const fieldWithImageAsset = fields.find(fieldDef => (fieldDef.fields || []).some(isImageAssetField));
  return fieldWithImageAsset ? "".concat(fieldWithImageAsset.name, ".asset") : void 0;
}
function isFileAssetField(fieldDef) {
  return fieldHasReferenceTo(fieldDef, "sanity.fileAsset");
}
function resolveFileAssetPath(typeDef) {
  const fields = typeDef.fields || [];
  const assetField = fields.find(isFileAssetField);
  if (assetField) {
    return assetField.name;
  }
  const fieldWithFileAsset = fields.find(fieldDef => (fieldDef.fields || []).some(isFileAssetField));
  return fieldWithFileAsset ? "".concat(fieldWithFileAsset.name, ".asset") : void 0;
}
function guessPreviewFields(rawObjectTypeDef) {
  const objectTypeDef = _objectSpread({
    fields: []
  }, rawObjectTypeDef);
  const stringFieldNames = objectTypeDef.fields.filter(field => field.type === "string").map(field => field.name);
  const blockFieldNames = objectTypeDef.fields.filter(isBlockField).map(field => field.name);
  let titleField = TITLE_CANDIDATES.find(candidate => stringFieldNames.includes(candidate) || blockFieldNames.includes(candidate));
  let descField = DESCRIPTION_CANDIDATES.find(candidate => candidate !== titleField && (stringFieldNames.includes(candidate) || blockFieldNames.includes(candidate)));
  if (!titleField) {
    titleField = stringFieldNames[0] || blockFieldNames[0];
    descField = stringFieldNames[1] || blockFieldNames[1];
  }
  const mediaField = objectTypeDef.fields.find(field => field.type === "image");
  const imageAssetPath = resolveImageAssetPath(objectTypeDef);
  if (!titleField) {
    const fileAssetPath = resolveFileAssetPath(objectTypeDef);
    if (fileAssetPath) {
      titleField = "".concat(fileAssetPath, ".originalFilename");
    }
    if (imageAssetPath) {
      titleField = "".concat(imageAssetPath, ".originalFilename");
    }
  }
  if (!titleField && !imageAssetPath) {
    const fieldNames = objectTypeDef.fields.map(field => field.name);
    const fieldMapping = fieldNames.reduce((acc, fieldName) => {
      acc[fieldName] = fieldName;
      return acc;
    }, {});
    return {
      select: fieldMapping,
      prepare: createFallbackPrepare(fieldNames)
    };
  }
  const select = omitBy({
    title: titleField,
    description: descField,
    media: mediaField ? mediaField.name : imageAssetPath
  }, isUndefined);
  return {
    select
  };
}
function warnIfPreviewOnOptions(type) {
  if (type.options && type.options.preview) {
    console.warn("Heads up! The preview config is no longer defined on \"options\", but instead on the type/field itself.\nPlease move {options: {preview: ...}} to {..., preview: ...} on the type/field definition of \"".concat(type.name, "\".\n"));
  }
}
function warnIfPreviewHasFields(type) {
  const preview = type.preview || (type.options || {}).preview;
  if (preview && "fields" in preview) {
    console.warn("Heads up! \"preview.fields\" should be renamed to \"preview.select\". Please update the preview config for \"".concat(type.name, "\".\n"));
  }
}
function parseSelection(selection) {
  return selection.reduce((acc, field) => {
    acc[field] = field;
    return acc;
  }, {});
}
function parsePreview(preview) {
  if (!preview) {
    return preview;
  }
  const select = preview.select || preview.fields || {};
  if (Array.isArray(select)) {
    return _objectSpread(_objectSpread({}, pick(preview, ["prepare", "component"])), {}, {
      select: parseSelection(select)
    });
  }
  return _objectSpread(_objectSpread({}, pick(preview, ["prepare", "component"])), {}, {
    select
  });
}
function createPreviewGetter(objectTypeDef) {
  return function previewGetter() {
    warnIfPreviewOnOptions(objectTypeDef);
    warnIfPreviewHasFields(objectTypeDef);
    const preview = parsePreview(objectTypeDef.preview || (objectTypeDef.options || {}).preview);
    return preview || guessPreviewFields(objectTypeDef);
  };
}
const CANDIDATES = ["title", "name", "label", "heading", "header", "caption", "description"];
const PRIMITIVES = ["string", "boolean", "number"];
const isPrimitive = field => PRIMITIVES.includes(field.type);
function guessOrderingConfig(objectTypeDef) {
  let candidates = CANDIDATES.filter(candidate => objectTypeDef.fields.some(field => isPrimitive(field) && field.name === candidate));
  if (candidates.length === 0) {
    candidates = objectTypeDef.fields.filter(isPrimitive).map(field => field.name);
  }
  return candidates.map(name => ({
    name,
    title: capitalize(startCase(name)),
    by: [{
      field: name,
      direction: "asc"
    }]
  }));
}
function normalizeSearchConfigs(configs) {
  if (!Array.isArray(configs)) {
    throw new Error("The search config of a document type must be an array of search config objects");
  }
  return configs.map(conf => {
    if (conf === "defaults") {
      return conf;
    }
    if (!isPlainObject(conf)) {
      throw new Error("Search config must be an object of {path: string, weight: number}");
    }
    return {
      weight: "weight" in conf ? conf.weight : 1,
      path: toPath(conf.path),
      mapWith: typeof conf.mapWith === "string" ? conf.mapWith : void 0
    };
  });
}
const stringFieldsSymbol = Symbol("__cachedStringFields");
const isReference = type => type.type && type.type.name === "reference";
const portableTextFields = ["style", "list"];
const isPortableTextBlock = type => type.name === "block" || type.type && isPortableTextBlock(type.type);
const isPortableTextArray = type => type.jsonType === "array" && Array.isArray(type.of) && type.of.some(isPortableTextBlock);
function reduceType(type, reducer, acc) {
  let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  let maxDepth = arguments.length > 4 ? arguments[4] : undefined;
  if (maxDepth < 0) {
    return acc;
  }
  const accumulator = reducer(acc, type, path);
  if (type.jsonType === "array" && Array.isArray(type.of)) {
    return reduceArray(type, reducer, accumulator, path, maxDepth);
  }
  if (type.jsonType === "object" && Array.isArray(type.fields) && !isReference(type)) {
    return reduceObject(type, reducer, accumulator, path, maxDepth);
  }
  return accumulator;
}
function reduceArray(arrayType, reducer, accumulator, path, maxDepth) {
  return arrayType.of.reduce((acc, ofType) => reduceType(ofType, reducer, acc, path, maxDepth - 1), accumulator);
}
function reduceObject(objectType, reducer, accumulator, path, maxDepth) {
  const isPtBlock = isPortableTextBlock(objectType);
  return objectType.fields.reduce((acc, field) => {
    if (isPtBlock && portableTextFields.includes(field.name)) {
      return acc;
    }
    const segment = [field.name].concat(field.type.jsonType === "array" ? [[]] : []);
    return reduceType(field.type, reducer, acc, path.concat(segment), maxDepth - 1);
  }, accumulator);
}
const BASE_WEIGHTS = [{
  weight: 1,
  path: ["_id"]
}, {
  weight: 1,
  path: ["_type"]
}];
const PREVIEW_FIELD_WEIGHT_MAP = {
  title: 10,
  subtitle: 5,
  description: 1.5
};
function deriveFromPreview(type) {
  var _a;
  const select = (_a = type == null ? void 0 : type.preview) == null ? void 0 : _a.select;
  if (!select) {
    return [];
  }
  return Object.keys(select).filter(fieldName => fieldName in PREVIEW_FIELD_WEIGHT_MAP).map(fieldName => ({
    weight: PREVIEW_FIELD_WEIGHT_MAP[fieldName],
    path: select[fieldName].split(".")
  }));
}
function getCachedStringFieldPaths(type, maxDepth) {
  if (!type[stringFieldsSymbol]) {
    type[stringFieldsSymbol] = uniqBy([...BASE_WEIGHTS, ...deriveFromPreview(type), ...getStringFieldPaths(type, maxDepth).map(path => ({
      weight: 1,
      path
    })), ...getPortableTextFieldPaths(type, maxDepth).map(path => ({
      weight: 1,
      path,
      mapWith: "pt::text"
    }))], spec => spec.path.join("."));
  }
  return type[stringFieldsSymbol];
}
function getCachedBaseFieldPaths(type) {
  if (!type[stringFieldsSymbol]) {
    type[stringFieldsSymbol] = uniqBy([...BASE_WEIGHTS, ...deriveFromPreview(type)], spec => spec.path.join("."));
  }
  return type[stringFieldsSymbol];
}
function getStringFieldPaths(type, maxDepth) {
  const reducer = (accumulator, childType, path) => childType.jsonType === "string" ? [...accumulator, path] : accumulator;
  return reduceType(type, reducer, [], [], maxDepth);
}
function getPortableTextFieldPaths(type, maxDepth) {
  const reducer = (accumulator, childType, path) => isPortableTextArray(childType) ? [...accumulator, path] : accumulator;
  return reduceType(type, reducer, [], [], maxDepth);
}
function resolveSearchConfigForBaseFieldPaths(type) {
  return getCachedBaseFieldPaths(type);
}
function resolveSearchConfig(type) {
  return getCachedStringFieldPaths(type, 4);
}
const OVERRIDABLE_FIELDS$5 = [...DEFAULT_OVERRIDEABLE_FIELDS, "orderings", "__experimental_search", "blockEditor", "icon"];
const ObjectType = {
  get() {
    return {
      name: "object",
      title: "Object",
      type: null,
      jsonType: "object"
    };
  },
  extend(rawSubTypeDef, createMemberType) {
    const subTypeDef = _objectSpread({
      fields: []
    }, rawSubTypeDef);
    const options = _objectSpread({}, subTypeDef.options || {});
    const parsed = Object.assign(pick(this.get(), OVERRIDABLE_FIELDS$5), subTypeDef, {
      type: this.get(),
      title: subTypeDef.title || (subTypeDef.name ? startCase(subTypeDef.name) : ""),
      options,
      orderings: subTypeDef.orderings || guessOrderingConfig(subTypeDef),
      fields: subTypeDef.fields.map(fieldDef => {
        const {
            name,
            fieldset,
            group
          } = fieldDef,
          rest = _objectWithoutProperties(fieldDef, _excluded);
        const compiledField = {
          name,
          group,
          fieldset
        };
        return lazyGetter(compiledField, "type", () => {
          return createMemberType(_objectSpread(_objectSpread({}, rest), {}, {
            title: fieldDef.title || startCase(name)
          }));
        });
      })
    });
    lazyGetter(parsed, "fieldsets", () => {
      return createFieldsets(subTypeDef, parsed.fields);
    });
    lazyGetter(parsed, "groups", () => {
      return createFieldsGroups(subTypeDef, parsed.fields);
    });
    lazyGetter(parsed, "preview", createPreviewGetter(subTypeDef));
    lazyGetter(parsed, "__experimental_search", () => {
      const userProvidedSearchConfig = subTypeDef.__experimental_search ? normalizeSearchConfigs(subTypeDef.__experimental_search) : null;
      if (userProvidedSearchConfig) {
        return userProvidedSearchConfig.map(entry => entry === "defaults" ? normalizeSearchConfigs(subTypeDef) : entry);
      }
      return resolveSearchConfig(parsed);
    }, {
      enumerable: false
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.fields) {
            throw new Error('Cannot override `fields` of subtypes of "object"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$5), {
            title: extensionDef.title || subTypeDef.title || (subTypeDef.name ? startCase(subTypeDef.name) : ""),
            type: parent
          });
          lazyGetter(current, "__experimental_search", () => parent.__experimental_search);
          return subtype(current);
        }
      };
    }
  }
};
function createFieldsets(typeDef, fields) {
  const fieldsetsDef = typeDef.fieldsets || [];
  const fieldsets = fieldsetsDef.map(fieldset => {
    const {
      name,
      title,
      description,
      options,
      group,
      hidden,
      readOnly
    } = fieldset;
    return {
      name,
      title,
      description,
      options,
      group,
      fields: [],
      hidden,
      readOnly
    };
  });
  const fieldsetsByName = keyBy(fieldsets, "name");
  return fields.map(field => {
    if (field.fieldset) {
      const fieldset = fieldsetsByName[field.fieldset];
      if (!fieldset) {
        throw new Error("Fieldset '".concat(field.fieldset, "' is not defined in schema for type '").concat(typeDef.name, "'"));
      }
      fieldset.fields.push(field);
      return fieldset.fields.length === 1 ? fieldset : null;
    }
    return {
      single: true,
      field
    };
  }).filter(Boolean);
}
function createFieldsGroups(typeDef, fields) {
  var _a;
  const groupsDef = typeDef.groups || [];
  const groups = groupsDef.map(group => {
    const {
      name,
      title,
      description,
      icon,
      readOnly,
      hidden
    } = group;
    return {
      name,
      title,
      description,
      icon,
      readOnly,
      default: group.default,
      hidden,
      fields: []
    };
  });
  const defaultGroups = groups.filter(group => group.default);
  if (defaultGroups.length > 1) {
    throw new Error("You currently have ".concat(defaultGroups.length, " default field groups defined for type '").concat(typeDef.name ? startCase(typeDef.name) : (_a = typeDef.title) != null ? _a : "", "', but only 1 is supported"));
  }
  const groupsByName = keyBy(groups, "name");
  fields.forEach(field => {
    if (field.group) {
      const fieldGroupNames = castArray(field.group);
      if (fieldGroupNames.length > 0) {
        fieldGroupNames.forEach(fieldGroupName => {
          var _a2, _b;
          const currentGroup = groupsByName[fieldGroupName];
          if (!currentGroup) {
            throw new Error("Field group '".concat(fieldGroupName, "' is not defined in schema for type '").concat((_b = (_a2 = typeDef.name) != null ? _a2 : typeDef.title) != null ? _b : "", "'"));
          }
          currentGroup.fields.push(field);
        });
      }
    }
  });
  return flatMap(groupsByName).filter(group => group.fields.length > 0);
}
const REF_FIELD$1 = {
  name: "_ref",
  title: "Referenced document ID",
  type: "string"
};
const WEAK_FIELD$1 = {
  name: "_weak",
  title: "Weak reference",
  type: "boolean"
};
const REFERENCE_FIELDS$1 = [REF_FIELD$1, WEAK_FIELD$1];
const OVERRIDABLE_FIELDS$4 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const REFERENCE_CORE = {
  name: "reference",
  title: "Reference",
  type: null,
  jsonType: "object"
};
function humanize$1(arr, conjunction) {
  const len = arr.length;
  if (len === 1) {
    return arr[0];
  }
  const first = arr.slice(0, len - 1);
  const last = arr[len - 1];
  return "".concat(first.join(", "), " ").concat(conjunction, " ").concat(last);
}
function buildTitle$1(type) {
  if (!type.to || type.to.length === 0) {
    return "Reference";
  }
  return "Reference to ".concat(humanize$1(arrify(type.to).map(toType => toType.title), "or").toLowerCase());
}
const ReferenceType = {
  get() {
    return REFERENCE_CORE;
  },
  extend(subTypeDef, createMemberType) {
    if (!subTypeDef.to) {
      throw new Error("Missing \"to\" field in reference definition. Check the type ".concat(subTypeDef.name));
    }
    const parsed = Object.assign(pick(REFERENCE_CORE, OVERRIDABLE_FIELDS$4), subTypeDef, {
      type: REFERENCE_CORE
    });
    lazyGetter(parsed, "fields", () => {
      return REFERENCE_FIELDS$1.map(fieldDef => {
        const {
            name
          } = fieldDef,
          type = _objectWithoutProperties(fieldDef, _excluded2);
        return {
          name,
          type: createMemberType(type)
        };
      });
    });
    lazyGetter(parsed, "fieldsets", () => {
      return createFieldsets(subTypeDef, parsed.fields);
    });
    lazyGetter(parsed, "to", () => {
      return arrify(subTypeDef.to).map(toType => createMemberType(toType));
    });
    lazyGetter(parsed, "title", () => subTypeDef.title || buildTitle$1(parsed));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.of) {
            throw new Error('Cannot override `of` of subtypes of "reference"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$4), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const REF_FIELD = {
  name: "_ref",
  title: "Referenced document ID",
  type: "string"
};
const WEAK_FIELD = {
  name: "_weak",
  title: "Weak reference marker",
  type: "boolean"
};
const REFERENCE_FIELDS = [REF_FIELD, WEAK_FIELD];
const OVERRIDABLE_FIELDS$3 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const CROSS_DATASET_REFERENCE_CORE = {
  name: "crossDatasetReference",
  type: null,
  jsonType: "object"
};
function humanize(arr, conjunction) {
  const len = arr.length;
  if (len === 1) {
    return arr[0];
  }
  const first = arr.slice(0, len - 1);
  const last = arr[len - 1];
  return "".concat(first.join(", "), " ").concat(conjunction, " ").concat(last);
}
function buildTitle(type) {
  if (!type.to || type.to.length === 0) {
    return "Cross dataset Reference";
  }
  return "Cross dataset reference to ".concat(humanize(arrify(type.to).map(toType => toType.title || capitalize(toType.type)), "or").toLowerCase());
}
const CrossDatasetReferenceType = {
  get() {
    return CROSS_DATASET_REFERENCE_CORE;
  },
  extend(subTypeDef, createMemberType) {
    if (!subTypeDef.to) {
      throw new Error("Missing \"to\" field in cross dataset reference definition. Check the type ".concat(subTypeDef.name));
    }
    const parsed = Object.assign(pick(CROSS_DATASET_REFERENCE_CORE, OVERRIDABLE_FIELDS$3), subTypeDef, {
      type: CROSS_DATASET_REFERENCE_CORE
    });
    lazyGetter(parsed, "fields", () => {
      return REFERENCE_FIELDS.map(fieldDef => {
        const {
            name
          } = fieldDef,
          type = _objectWithoutProperties(fieldDef, _excluded3);
        return {
          name,
          type: createMemberType(type)
        };
      });
    });
    lazyGetter(parsed, "to", () => {
      return arrify(subTypeDef.to).map(toType => {
        return _objectSpread(_objectSpread({}, toType), {}, {
          __experimental_search: resolveSearchConfigForBaseFieldPaths(toType)
        });
      });
    });
    lazyGetter(parsed, "title", () => subTypeDef.title || buildTitle(parsed));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.of) {
            throw new Error('Cannot override `of` of subtypes of "reference"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$3), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const ASSET_FIELD$1 = {
  name: "asset",
  type: "reference",
  to: [{
    type: "sanity.imageAsset"
  }]
};
const HOTSPOT_FIELD = {
  name: "hotspot",
  type: "sanity.imageHotspot"
};
const CROP_FIELD = {
  name: "crop",
  type: "sanity.imageCrop"
};
const OVERRIDABLE_FIELDS$2 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const IMAGE_CORE = {
  name: "image",
  title: "Image",
  type: null,
  jsonType: "object"
};
const DEFAULT_OPTIONS$3 = {};
const ImageType = {
  get() {
    return IMAGE_CORE;
  },
  extend(subTypeDef, extendMember) {
    const options = _objectSpread({}, subTypeDef.options || DEFAULT_OPTIONS$3);
    let hotspotFields = [HOTSPOT_FIELD, CROP_FIELD];
    if (!options.hotspot) {
      hotspotFields = hotspotFields.map(field => _objectSpread(_objectSpread({}, field), {}, {
        hidden: true
      }));
    }
    const fields = [ASSET_FIELD$1, ...hotspotFields, ...(subTypeDef.fields || [])];
    const parsed = Object.assign(pick(IMAGE_CORE, OVERRIDABLE_FIELDS$2), subTypeDef, {
      type: IMAGE_CORE,
      title: subTypeDef.title || startCase(subTypeDef.name || subTypeDef.type || ""),
      options,
      isCustomized: Boolean(subTypeDef.fields)
    });
    lazyGetter(parsed, "fields", () => {
      return fields.map(fieldDef => {
        const {
            name,
            fieldset
          } = fieldDef,
          type = _objectWithoutProperties(fieldDef, _excluded4);
        return {
          name,
          fieldset,
          type: extendMember(type)
        };
      });
    });
    lazyGetter(parsed, "fieldsets", () => {
      return createFieldsets(subTypeDef, parsed.fields);
    });
    lazyGetter(parsed, "preview", createPreviewGetter(Object.assign({}, subTypeDef, {
      fields
    })));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.fields) {
            throw new Error('Cannot override `fields` of subtypes of "image"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$2), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const ASSET_FIELD = {
  name: "asset",
  type: "reference",
  to: {
    type: "sanity.fileAsset"
  }
};
const OVERRIDABLE_FIELDS$1 = [...DEFAULT_OVERRIDEABLE_FIELDS];
const FILE_CORE = {
  name: "file",
  title: "File",
  type: null,
  jsonType: "object"
};
const DEFAULT_OPTIONS$2 = {
  accept: ""
};
const FileType = {
  get() {
    return FILE_CORE;
  },
  extend(subTypeDef, extendMember) {
    const options = _objectSpread({}, subTypeDef.options || DEFAULT_OPTIONS$2);
    const fields = [ASSET_FIELD, ...(subTypeDef.fields || [])];
    const parsed = Object.assign(pick(FILE_CORE, OVERRIDABLE_FIELDS$1), subTypeDef, {
      type: FILE_CORE,
      options,
      isCustomized: Boolean(subTypeDef.fields)
    });
    lazyGetter(parsed, "fields", () => {
      return fields.map(fieldDef => {
        const {
            name,
            fieldset
          } = fieldDef,
          type = _objectWithoutProperties(fieldDef, _excluded5);
        return {
          name,
          fieldset,
          type: extendMember(type)
        };
      });
    });
    lazyGetter(parsed, "fieldsets", () => {
      return createFieldsets(subTypeDef, parsed.fields);
    });
    lazyGetter(parsed, "preview", createPreviewGetter(Object.assign({}, subTypeDef, {
      fields
    })));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.fields) {
            throw new Error('Cannot override `fields` of subtypes of "file"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS$1), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const DOCUMENT_CORE = {
  name: "document",
  title: "Document",
  type: null,
  jsonType: "object"
};
const DocumentType = {
  get() {
    return DOCUMENT_CORE;
  },
  extend: ObjectType.extend
};
const OVERRIDABLE_FIELDS = [...DEFAULT_OVERRIDEABLE_FIELDS];
const ARRAY_CORE = {
  name: "array",
  type: null,
  jsonType: "array",
  of: []
};
const ArrayType = {
  get() {
    return ARRAY_CORE;
  },
  extend(subTypeDef, createMemberType) {
    const parsed = Object.assign(pick(ARRAY_CORE, OVERRIDABLE_FIELDS), subTypeDef, {
      type: ARRAY_CORE
    });
    lazyGetter(parsed, "of", () => {
      return subTypeDef.of.map(ofTypeDef => {
        return createMemberType(ofTypeDef);
      });
    });
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.of) {
            throw new Error('Cannot override `of` property of subtypes of "array"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, OVERRIDABLE_FIELDS), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
const DEFAULT_LINK_ANNOTATION = {
  type: "object",
  name: "link",
  options: {
    modal: {
      type: "popover"
    }
  },
  fields: [{
    name: "href",
    type: "url",
    title: "Url",
    validation: Rule => Rule.uri({
      scheme: ["http", "https", "tel", "mailto"],
      allowRelative: true
    })
  }]
};
const DEFAULT_TEXT_FIELD = {
  type: "text",
  name: "text",
  title: "Text"
};
const DEFAULT_MARKS_FIELD = {
  name: "marks",
  type: "array",
  of: [{
    type: "string"
  }],
  title: "Marks"
};
const LIST_TYPES = {
  bullet: {
    title: "Bullet",
    value: "bullet"
  },
  numbered: {
    title: "Numbered",
    value: "number"
  }
};
const DEFAULT_LIST_TYPES = [LIST_TYPES.bullet, LIST_TYPES.numbered];
const BLOCK_STYLES = {
  normal: {
    title: "Normal",
    value: "normal"
  },
  h1: {
    title: "Heading 1",
    value: "h1"
  },
  h2: {
    title: "Heading 2",
    value: "h2"
  },
  h3: {
    title: "Heading 3",
    value: "h3"
  },
  h4: {
    title: "Heading 4",
    value: "h4"
  },
  h5: {
    title: "Heading 5",
    value: "h5"
  },
  h6: {
    title: "Heading 6",
    value: "h6"
  },
  blockquote: {
    title: "Quote",
    value: "blockquote"
  }
};
const DEFAULT_BLOCK_STYLES = [BLOCK_STYLES.normal, BLOCK_STYLES.h1, BLOCK_STYLES.h2, BLOCK_STYLES.h3, BLOCK_STYLES.h4, BLOCK_STYLES.h5, BLOCK_STYLES.h6, BLOCK_STYLES.blockquote];
const DECORATOR_STRONG = {
  title: "Strong",
  value: "strong"
};
const DECORATOR_EMPHASIS = {
  title: "Emphasis",
  value: "em"
};
const DECORATOR_CODE = {
  title: "Code",
  value: "code"
};
const DECORATOR_UNDERLINE = {
  title: "Underline",
  value: "underline"
};
const DECORATOR_STRIKE = {
  title: "Strike",
  value: "strike-through"
};
const DECORATORS = {
  strong: DECORATOR_STRONG,
  em: DECORATOR_EMPHASIS,
  code: DECORATOR_CODE,
  underline: DECORATOR_UNDERLINE,
  strikeThrough: DECORATOR_STRIKE
};
const DEFAULT_DECORATORS = [DECORATORS.strong, DECORATORS.em, DECORATORS.code, DECORATORS.underline, DECORATORS.strikeThrough];
const INHERITED_FIELDS$1 = ["type", "name", "title", "jsonType", "description", "options", "fieldsets", "icon"];
const BLOCK_CORE = {
  name: "block",
  title: "Block",
  type: null,
  jsonType: "object"
};
const DEFAULT_OPTIONS$1 = {};
const BlockType = {
  get() {
    return BLOCK_CORE;
  },
  extend(subTypeDef, extendMember) {
    const options = _objectSpread({}, subTypeDef.options || DEFAULT_OPTIONS$1);
    const {
        marks,
        styles,
        lists,
        of
      } = subTypeDef,
      rest = _objectWithoutProperties(subTypeDef, _excluded6);
    const childrenField = createChildrenField(marks, of);
    const styleField = createStyleField(styles);
    const listField = createListField(lists);
    const markDefsField = {
      name: "markDefs",
      title: "Mark definitions",
      type: "array",
      of: (marks == null ? void 0 : marks.annotations) || DEFAULT_ANNOTATIONS
    };
    const fields = [childrenField, styleField, listField, markDefsField].concat(subTypeDef.fields || []);
    const parsed = Object.assign(pick(BLOCK_CORE, INHERITED_FIELDS$1), rest, {
      type: BLOCK_CORE,
      options
    });
    lazyGetter(parsed, "fields", () => {
      return fields.map(fieldDef => {
        const {
            name
          } = fieldDef,
          type = _objectWithoutProperties(fieldDef, _excluded7);
        return {
          name,
          type: extendMember(type)
        };
      });
    });
    lazyGetter(parsed, "preview", createPreviewGetter(subTypeDef));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.fields) {
            throw new Error('Cannot override `fields` of subtypes of "block"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, INHERITED_FIELDS$1), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
function ensureNormalStyle(styles) {
  return styles.some(style => style.value === "normal") ? styles : [BLOCK_STYLES.normal, ...styles];
}
function createStyleField(styles) {
  return {
    name: "style",
    title: "Style",
    type: "string",
    options: {
      list: ensureNormalStyle(styles || DEFAULT_BLOCK_STYLES)
    }
  };
}
function createListField(lists) {
  return {
    name: "list",
    title: "List type",
    type: "string",
    options: {
      list: lists || DEFAULT_LIST_TYPES
    }
  };
}
const DEFAULT_ANNOTATIONS = [DEFAULT_LINK_ANNOTATION];
function createChildrenField(marks) {
  let of = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return {
    name: "children",
    title: "Content",
    type: "array",
    of: [{
      type: "span",
      fields: [DEFAULT_TEXT_FIELD, DEFAULT_MARKS_FIELD],
      annotations: marks && marks.annotations ? marks.annotations : DEFAULT_ANNOTATIONS,
      decorators: marks && marks.decorators ? marks.decorators : DEFAULT_DECORATORS
    }, ...of.filter(memberType => memberType.type !== "span")]
  };
}
const INHERITED_FIELDS = ["type", "name", "title", "jsonType", "description", "options", "fieldsets", "icon"];
const SPAN_CORE = {
  name: "span",
  title: "Span",
  type: null,
  jsonType: "object"
};
const MARKS_FIELD = {
  name: "marks",
  title: "Marks",
  type: "array",
  of: [{
    type: "string"
  }]
};
const TEXT_FIELD = {
  name: "text",
  title: "Text",
  type: "string"
};
const DEFAULT_OPTIONS = {};
const SpanType = {
  get() {
    return SPAN_CORE;
  },
  extend(subTypeDef, extendMember) {
    const options = _objectSpread({}, subTypeDef.options || DEFAULT_OPTIONS);
    const {
      annotations = [],
      marks = []
    } = subTypeDef;
    const fields = [MARKS_FIELD, TEXT_FIELD];
    const parsed = Object.assign(pick(SPAN_CORE, INHERITED_FIELDS), subTypeDef, {
      type: SPAN_CORE,
      options
    });
    lazyGetter(parsed, "fields", () => {
      return fields.map(fieldDef => {
        const {
            name
          } = fieldDef,
          type = _objectWithoutProperties(fieldDef, _excluded8);
        return {
          name,
          type: extendMember(type)
        };
      });
    });
    lazyGetter(parsed, "annotations", () => annotations.map(extendMember));
    lazyGetter(parsed, "marks", () => marks.map(extendMember));
    lazyGetter(parsed, "preview", createPreviewGetter(subTypeDef));
    return subtype(parsed);
    function subtype(parent) {
      return {
        get() {
          return parent;
        },
        extend: extensionDef => {
          if (extensionDef.fields) {
            throw new Error('Cannot override `fields` of subtypes of "span"');
          }
          const current = Object.assign({}, parent, pick(extensionDef, INHERITED_FIELDS), {
            type: parent
          });
          return subtype(current);
        }
      };
    }
  }
};
var types = /*#__PURE__*/Object.freeze({
  __proto__: null,
  any: AnyType,
  string: StringType,
  text: TextType,
  datetime: DateTimeType,
  date: DateType,
  boolean: BooleanType,
  url: UrlType,
  email: EmailType,
  number: NumberType,
  reference: ReferenceType,
  crossDatasetReference: CrossDatasetReferenceType,
  image: ImageType,
  file: FileType,
  object: ObjectType,
  document: DocumentType,
  array: ArrayType,
  block: BlockType,
  span: SpanType
});
function compileRegistry(schemaDef) {
  const registry = Object.assign( /* @__PURE__ */Object.create(null), types);
  const defsByName = schemaDef.types.reduce((acc, def) => {
    if (acc[def.name]) {
      throw new Error("Duplicate type name added to schema: ".concat(def.name));
    }
    acc[def.name] = def;
    return acc;
  }, {});
  schemaDef.types.forEach(add);
  return registry;
  function ensure(typeName) {
    if (!registry[typeName]) {
      if (!defsByName[typeName]) {
        throw new Error("Unknown type: ".concat(typeName));
      }
      add(defsByName[typeName]);
    }
  }
  function extendMember(memberDef) {
    ensure(memberDef.type);
    return registry[memberDef.type].extend(memberDef, extendMember).get();
  }
  function add(typeDef) {
    ensure(typeDef.type);
    if (registry[typeDef.name]) {
      return;
    }
    registry[typeDef.name] = registry[typeDef.type].extend(typeDef, extendMember);
  }
}
class Schema {
  static compile(schemaDef) {
    return new Schema(schemaDef);
  }
  constructor(schemaDef) {
    this._original = schemaDef;
    this._registry = compileRegistry(schemaDef);
  }
  get name() {
    return this._original.name;
  }
  get(name) {
    return this._registry[name] && this._registry[name].get();
  }
  has(name) {
    return name in this._registry;
  }
  getTypeNames() {
    return Object.keys(this._registry);
  }
}
export { Schema as default };
//# sourceMappingURL=index.esm.js.map
