{"version":3,"file":"index.esm.js","sources":["../src/helpers.ts","../src/reference/asserters.ts","../src/assets/asserters.ts","../src/crossDatasetReference/asserters.ts","../src/documents/asserters.ts","../src/markers/asserters.ts","../src/mutations/asserters.ts","../src/paths/asserters.ts","../src/portableText/asserters.ts","../src/schema/asserters.ts","../src/schema/define.ts","../src/transactionLog/asserters.ts","../src/validation/asserters.ts"],"sourcesContent":["export function isObject(obj: unknown): obj is Record<string, unknown> {\n  return typeof obj === 'object' && obj !== null && !Array.isArray(obj)\n}\n","import {isObject} from '../helpers'\nimport type {Reference} from './types'\n\n/** @internal */\nexport function isReference(reference: unknown): reference is Reference {\n  return isObject(reference) && typeof reference._ref === 'string'\n}\n","import {isObject} from '../helpers'\nimport {isReference} from '../reference'\nimport type {Image} from './types'\n\n/** @public */\nexport function isImage(value: unknown): value is Image {\n  return isObject(value) && isReference(value.asset) && value.asset._ref.startsWith('image-')\n}\n","import {isObject} from '../helpers'\nimport type {CrossDatasetReferenceValue} from './types'\n\n/** @beta */\nexport function isCrossDatasetReference(\n  reference: unknown\n): reference is CrossDatasetReferenceValue {\n  return (\n    isObject(reference) &&\n    typeof reference._ref === 'string' &&\n    typeof reference._dataset === 'string' &&\n    typeof reference._projectId === 'string'\n  )\n}\n","import {isObject} from '../helpers'\nimport type {KeyedObject, SanityDocument, TypedObject} from './types'\n\n/** @public */\nexport function isSanityDocument(document: unknown): document is SanityDocument {\n  return (\n    isObject(document) && typeof document._id === 'string' && typeof document._type === 'string'\n  )\n}\n\n/** @public */\nexport function isTypedObject(obj: unknown): obj is TypedObject {\n  return isObject(obj) && typeof obj._type === 'string'\n}\n\n/** @public */\nexport function isKeyedObject(obj: unknown): obj is KeyedObject {\n  return isObject(obj) && typeof obj._key === 'string'\n}\n","import type {ValidationMarker} from './types'\n\n/** @internal */\nexport function isValidationErrorMarker(\n  marker: ValidationMarker\n): marker is ValidationMarker & {level: 'error'} {\n  return marker.level === 'error'\n}\n\n/** @internal */\nexport function isValidationWarningMarker(\n  marker: ValidationMarker\n): marker is ValidationMarker & {level: 'warning'} {\n  return marker.level === 'warning'\n}\n\n/** @internal */\nexport function isValidationInfoMarker(\n  marker: ValidationMarker\n): marker is ValidationMarker & {level: 'info'} {\n  return marker.level === 'info'\n}\n","import type {TransactionLogMutation} from '../transactionLog'\nimport type {\n  CreateIfNotExistsMutation,\n  CreateMutation,\n  CreateOrReplaceMutation,\n  DeleteMutation,\n  Mutation,\n  PatchMutation,\n} from './types'\n\n/** @internal */\nexport function isCreateMutation(\n  mutation: Mutation | TransactionLogMutation\n): mutation is CreateMutation {\n  return 'create' in mutation\n}\n\n/** @internal */\nexport function isCreateIfNotExistsMutation(\n  mutation: Mutation | TransactionLogMutation\n): mutation is CreateIfNotExistsMutation {\n  return 'createIfNotExists' in mutation\n}\n\n/** @internal */\nexport function isCreateOrReplaceMutation(\n  mutation: Mutation | TransactionLogMutation\n): mutation is CreateOrReplaceMutation {\n  return 'createOrReplace' in mutation\n}\n\n/** @internal */\nexport function isDeleteMutation(\n  mutation: Mutation | TransactionLogMutation\n): mutation is DeleteMutation {\n  return 'delete' in mutation\n}\n\n/** @internal */\nexport function isPatchMutation(\n  mutation: Mutation | TransactionLogMutation\n): mutation is PatchMutation {\n  return 'patch' in mutation\n}\n","import type {PathSegment, KeyedSegment, IndexTuple} from './types'\n\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/\nconst reIndexTuple = /^\\d*:\\d*$/\n\n/** @internal */\nexport function isIndexSegment(segment: PathSegment): segment is number {\n  return typeof segment === 'number' || (typeof segment === 'string' && /^\\[\\d+\\]$/.test(segment))\n}\n\n/** @internal */\nexport function isKeySegment(segment: PathSegment): segment is KeyedSegment {\n  if (typeof segment === 'string') {\n    return reKeySegment.test(segment.trim())\n  }\n\n  return typeof segment === 'object' && '_key' in segment\n}\n\n/** @internal */\nexport function isIndexTuple(segment: PathSegment): segment is IndexTuple {\n  if (typeof segment === 'string' && reIndexTuple.test(segment)) {\n    return true\n  }\n\n  if (!Array.isArray(segment) || segment.length !== 2) {\n    return false\n  }\n\n  const [from, to] = segment\n  return (typeof from === 'number' || from === '') && (typeof to === 'number' || to === '')\n}\n","import type {Block, Span} from './types'\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value == 'object' || typeof value == 'function')\n}\n\n/** @internal */\nexport function isBlock<T = Span>(value: unknown): value is Block<T> {\n  return (\n    isRecord(value) &&\n    typeof value._type === 'string' && // block types can be named, so expect anything here.\n    typeof value.style === 'string' &&\n    Array.isArray(value.children) &&\n    Array.isArray(value.markDefs)\n  )\n}\n\n/** @internal */\nexport function isSpan(value: unknown): value is Span {\n  return (\n    isRecord(value) &&\n    value._type === 'span' &&\n    typeof value.text === 'string' &&\n    Array.isArray(value.marks)\n  )\n}\n","import type {CrossDatasetReferenceSchemaType} from '../crossDatasetReference'\nimport {TitledListValue} from './definition'\nimport type {\n  BlockSchemaType,\n  ArraySchemaType,\n  ObjectSchemaType,\n  ReferenceSchemaType,\n  SpanSchemaType,\n  BlockChildrenObjectField,\n  StyleObjectField,\n  ListObjectField,\n  BooleanSchemaType,\n  StringSchemaType,\n  NumberSchemaType,\n  SchemaType,\n} from './types'\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value == 'object' || typeof value == 'function')\n}\n\n/**\n * Returns wether or not the given type is a document type\n * (eg that it was defined as `type: 'document'`)\n *\n * @param type - Schema type to test\n * @returns True if type is a document type, false otherwise\n *\n * @public\n */\nexport function isDocumentSchemaType(type: unknown): type is ObjectSchemaType {\n  if (!isObjectSchemaType(type)) {\n    return false\n  }\n\n  let current: SchemaType | undefined = type as SchemaType\n  while (current) {\n    if (current.name === 'document') {\n      return true\n    }\n\n    current = current.type\n  }\n  return false\n}\n\n/** @internal */\nexport function isObjectSchemaType(type: unknown): type is ObjectSchemaType {\n  if (!isRecord(type)) return false\n  return type.jsonType === 'object'\n}\n\n/** @internal */\nexport function isArraySchemaType(type: unknown): type is ArraySchemaType {\n  if (!isRecord(type)) return false\n  return type.jsonType === 'array'\n}\n\n/** @internal */\nexport function isArrayOfObjectsSchemaType(\n  type: unknown\n): type is ArraySchemaType<ObjectSchemaType> {\n  return isArraySchemaType(type) && type.of.every((memberType) => isObjectSchemaType(memberType))\n}\n\n/** @internal */\nexport function isArrayOfPrimitivesSchemaType(type: unknown): type is ArraySchemaType {\n  return isArraySchemaType(type) && type.of.every((memberType) => isPrimitiveSchemaType(memberType))\n}\n\n/** @internal */\nexport function isBooleanSchemaType(type: unknown): type is BooleanSchemaType {\n  if (!isRecord(type)) return false\n  return type.jsonType === 'boolean'\n}\n\n/** @internal */\nexport function isStringSchemaType(type: unknown): type is StringSchemaType {\n  if (!isRecord(type)) return false\n  return type.jsonType === 'string'\n}\n\n/** @internal */\nexport function isNumberSchemaType(type: unknown): type is NumberSchemaType {\n  if (!isRecord(type)) return false\n  return type.jsonType === 'number'\n}\n\n/** @internal */\nexport function isPrimitiveSchemaType(\n  type: unknown\n): type is BooleanSchemaType | StringSchemaType | NumberSchemaType {\n  return isBooleanSchemaType(type) || isStringSchemaType(type) || isNumberSchemaType(type)\n}\n\n/** @internal */\nexport function isReferenceSchemaType(type: unknown): type is ReferenceSchemaType {\n  return isRecord(type) && (type.name === 'reference' || isReferenceSchemaType(type.type))\n}\n\n/** @internal */\nexport function isCrossDatasetReferenceSchemaType(\n  type: unknown\n): type is CrossDatasetReferenceSchemaType {\n  return (\n    isRecord(type) &&\n    (type.name === 'crossDatasetReference' || isCrossDatasetReferenceSchemaType(type.type))\n  )\n}\n\n/** @internal */\nexport function isTitledListValue(item: unknown): item is TitledListValue {\n  return typeof item === 'object' && item !== null && 'title' in item && 'value' in item\n}\n\n/** @internal */\nexport function isSpanSchemaType(type: unknown): type is SpanSchemaType {\n  if (!isRecord(type)) return false\n  // we check for `annotations` and `decorators` instead of `type.name` because\n  // schema names can technically change if someone extends the type\n  return Array.isArray(type.annotations) && Array.isArray(type.decorators)\n}\n\n/** @internal */\nexport function isBlockSchemaType(type: unknown): type is BlockSchemaType {\n  if (!isRecord(type)) return false\n  if (!Array.isArray(type.fields)) return false\n\n  const [maybeSpanChildren, maybeStyle, maybeList] = type.fields\n  return (\n    isBlockChildrenObjectField(maybeSpanChildren) &&\n    isStyleObjectField(maybeStyle) &&\n    isListObjectField(maybeList)\n  )\n}\n\n/** @internal */\nexport function isStyleObjectField(field: unknown): field is StyleObjectField {\n  if (!isRecord(field)) return false\n  if (field.name !== 'style') return false\n  return isRecord(field.type) && field.type.jsonType === 'string'\n}\n\n/** @internal */\nexport function isListObjectField(field: unknown): field is ListObjectField {\n  if (!isRecord(field)) return false\n  if (field.name !== 'list') return false\n  return isRecord(field.type) && field.type.jsonType === 'string'\n}\n\n/** @internal */\nexport function isBlockChildrenObjectField(field: unknown): field is BlockChildrenObjectField {\n  if (!isRecord(field)) return false\n  if (field.name !== 'children') return false\n  if (!isArraySchemaType(field.type)) return false\n  // there will always be a span item in `SpanChildrenObjectField`\n  return field.type.of.some(isSpanSchemaType)\n}\n","import type {\n  DefineArrayMemberBase,\n  DefineSchemaOptions,\n  DefineSchemaBase,\n  MaybeAllowUnknownProps,\n  NarrowPreview,\n  StrictDefinition,\n  WidenInitialValue,\n  WidenValidation,\n} from './defineTypes'\nimport {FieldDefinitionBase, IntrinsicTypeName} from './definition'\n\n/**\n * Helper function for defining a Sanity type definition. This function does not do anything on its own;\n * it exists to check that your schema definition is correct, and help autocompletion in your IDE.\n *\n * This function will narrow the schema type down to fields and options based on the provided type-string.\n *\n * Schemas defined using `defineType` should typically be added to the Studio config under `schema.types`.\n * Defined types can be referenced by their `name`. This is referred to as a type-alias.\n *\n * When using type-aliases as `type`, `defineType` cannot know the base-type, so type-safety will be reduced.\n * If you know the base type of the type-alias, provide `defineOptions.aliasFor: <base type name>`.\n * This will enforce that the schema definition conforms with the provided type.\n *\n * By default, `defineType` only allows known properties and options.\n * Use `defineOptions.strict: false` to allow unknown properties and options.\n *\n * ### Basic usage\n *\n * ```ts\n * defineType({\n *   type: 'object',\n *   name: 'custom-object',\n *   fields: [ {type: 'string', name: 'title', title: 'Title'}],\n * })\n * ```\n *\n * ### Usage with aliasFor narrowing\n *\n * ```ts\n * defineType({\n *   type: 'custom-object',\n *   name: 'redefined-custom-object',\n *   options: {\n *     columns: 2\n *   }\n * }, {aliasFor: 'object' })\n * ```\n *\n * ### Allow unknown properties\n *\n * ```ts\n * defineType({\n *   type: 'custom-object',\n *   name: 'redefined-custom-object',\n *   allowsUnknownProperties: true\n *   options: {\n *     columns: 2,\n *     allowsUnknownOptions: true\n *   }\n * }, {strict: false})\n * ```\n * ### Maximum safety and best autocompletion\n *\n * Use {@link defineType}, {@link defineField} and {@link defineArrayMember}:\n *\n * ```ts\n *  defineType({\n *    type: 'object',\n *    name: 'custom-object',\n *    fields: [\n *      defineField({\n *        type: 'array',\n *        name: 'arrayField',\n *        title: 'Things',\n *        of: [\n *          defineArrayMember({\n *            type: 'object',\n *            name: 'type-name-in-array',\n *            fields: [defineField({type: 'string', name: 'title', title: 'Title'})],\n *          }),\n *        ],\n *      }),\n *    ],\n *  })\n * ```\n *\n * ## Note on type-safety in the current implementation\n *\n * Type-safety inside array-like properties (schema properties like `fields` and `of`) can only be guaranteed when\n * {@link defineField} and {@link defineArrayMember} are used to wrap each value in the array.\n *\n * For array-values without a function-wrapper, TypeScript will resolve to a union type of all possible properties across\n * all schema types. This result in less precise typing.\n *\n * ### Extending the Sanity Schema types\n *\n * If you want to extend the Sanity Schema types with your own properties or options to make them typesafe,\n * you can use [TypeScript declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html).\n *\n * With declaration merging, properties and options will be available in a type-safe manner, and\n * `strict: false` will not be necessary.\n *\n * #### Example: Add option to StringOptions\n *\n * ```ts\n * // string.ts\n *\n * //redeclare the sanity module\n * declare module 'sanity' {\n *  // redeclare StringOptions; it will be merged with StringOptions in the sanity module\n *  export interface StringOptions {\n *    myCustomOption?: boolean\n *  }\n * }\n *\n * // the option is now part of the StringOptions type, just as if it was declared in the sanity codebase:\n * defineType({\n *   type: 'string',\n *   name: 'my-string',\n *   options: {\n *     myCustomOption: true // this does not give an error anymore\n *   }\n * })\n *\n * ```\n *\n * #### Example: Add a schema definition to \"intrinsic-types\"\n *\n * ```ts\n * //my-custom-type-definition.ts\n *\n * // create a new schema definition based on object (we remove the ability to assign field, change the type add some options)\n *  export type MagicallyAddedDefinition = Omit<Schema.ObjectDefinition, 'type' | 'fields'> & {\n *    type: 'magically-added-type'\n *    options?: {\n *      sparkles?: boolean\n *    }\n *  }\n *\n *  // redeclares sanity module so we can add interfaces props to it\n * declare module 'sanity' {\n *     // redeclares IntrinsicDefinitions and adds a named definition to it\n *     // it is important that the key is the same as the type in the definition ('magically-added-type')\n *     export interface IntrinsicDefinitions {\n *       'magically-added-type': MagicallyAddedDefinition\n *     }\n * }\n *\n * // defineType will now narrow `type: 'magically-added-type'` to `MagicallyAddedDefinition`\n * defineType({\n *   type: 'magically-added-type'\n *   name: 'magic',\n *   options: {\n *     sparkles: true // this is allowed,\n *     //@ts-expect-error this is not allowed in MagicallyAddedDefinition.options\n *     sparks: true\n *   }\n * })\n * ```\n *\n * @param schemaDefinition - should be a valid schema type definition.\n * @param defineOptions - optional param to provide type hints for `schemaDefinition`.\n *\n * @see defineField\n * @see defineArrayMember\n * @see typed\n *\n * @beta\n */\nexport function defineType<\n  TType extends string | IntrinsicTypeName, // IntrinsicTypeName here improves autocompletion in _some_ IDEs (not VS Code atm)\n  TName extends string,\n  TSelect extends Record<string, string> | undefined,\n  TPrepareValue extends Record<keyof TSelect, any> | undefined,\n  TAlias extends IntrinsicTypeName | undefined,\n  TStrict extends StrictDefinition\n>(\n  schemaDefinition: {\n    type: TType\n    name: TName\n  } & DefineSchemaBase<TType, TAlias> &\n    NarrowPreview<TType, TAlias, TSelect, TPrepareValue> &\n    MaybeAllowUnknownProps<TStrict>,\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  defineOptions?: DefineSchemaOptions<TStrict, TAlias>\n): typeof schemaDefinition {\n  return schemaDefinition\n}\n\n/**\n * Define a field within a document, object, image or file definition `fields` array.\n *\n * This function will narrow the schema type down to fields and options based on the provided\n * type-string.\n *\n * Using `defineField` is optional, but should provide improved autocompletion in your IDE, when building your schema.\n * Field-properties like `validation` and `initialValue`will also be more specific.\n *\n * See {@link defineType} for more examples.\n *\n * @param schemaField - should be a valid field type definition.\n * @param defineOptions - optional param to provide type hints for `schemaField`.\n *\n * @see defineField\n * @see defineArrayMember\n * @see typed\n *\n * @beta\n */\nexport function defineField<\n  TType extends string | IntrinsicTypeName, // IntrinsicTypeName here improves autocompletion in _some_ IDEs (not VS Code atm)\n  TName extends string,\n  TSelect extends Record<string, string> | undefined,\n  TPrepareValue extends Record<keyof TSelect, any> | undefined,\n  TAlias extends IntrinsicTypeName | undefined,\n  TStrict extends StrictDefinition\n>(\n  schemaField: {\n    type: TType\n    name: TName\n  } & DefineSchemaBase<TType, TAlias> &\n    NarrowPreview<TType, TAlias, TSelect, TPrepareValue> &\n    MaybeAllowUnknownProps<TStrict> &\n    FieldDefinitionBase,\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  defineOptions?: DefineSchemaOptions<TStrict, TAlias>\n): typeof schemaField & WidenValidation & WidenInitialValue {\n  return schemaField\n}\n\n/**\n * Define an array item member type within an array definition `of`-array.\n *\n * This function will narrow the schema type down to fields and options based on the provided\n * `type` string.\n *\n * Using `defineArrayMember` is optional, but should provide improved autocompletion in your IDE, when building your schema.\n * Field properties like `validation` and `initialValue` will also be more specific.\n *\n * See {@link defineType} for example usage.\n *\n * @param arrayOfSchema - should be a valid `array.of` member definition.\n * @param defineOptions - optional param to provide type hints for `arrayOfSchema`.\n *\n * @see defineType\n * @see defineField\n * @see typed\n *\n * @beta\n */\nexport function defineArrayMember<\n  TType extends string | IntrinsicTypeName, // IntrinsicTypeName here improves autocompletion in _some_ IDEs (not VS Code atm)\n  TName extends string,\n  TSelect extends Record<string, string> | undefined,\n  TPrepareValue extends Record<keyof TSelect, any> | undefined,\n  TAlias extends IntrinsicTypeName | undefined,\n  TStrict extends StrictDefinition\n>(\n  arrayOfSchema: {\n    type: TType\n    /**\n     * When provided, `name` is used as `_type` for the array item when stored.\n     *\n     * Necessary when an array contains multiple entries with the same `type`, each with\n     * different configuration (title and initialValue for instance).\n     */\n    name?: TName\n  } & DefineArrayMemberBase<TType, TAlias> &\n    NarrowPreview<TType, TAlias, TSelect, TPrepareValue> &\n    MaybeAllowUnknownProps<TStrict>,\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  defineOptions?: DefineSchemaOptions<TStrict, TAlias>\n): typeof arrayOfSchema & WidenValidation & WidenInitialValue {\n  return arrayOfSchema\n}\n\n/**\n * `typed` can be used to ensure that an object conforms to an exact interface.\n *\n * It can be useful when working with `defineType` and `defineField` on occasions where a wider type with\n * custom options or properties is required.\n *\n * ## Example  usage\n * ```ts\n *  defineField({\n *    type: 'string',\n *    name: 'nestedField',\n *    options: typed<StringOptions & {myCustomOption: boolean}>({\n *      layout: 'radio',\n *      // allowed\n *      myCustomOption: true,\n *      //@ts-expect-error unknownProp is not part of StringOptions & {myCustomOption: boolean}\n *      unknownProp: 'not allowed in typed context',\n *    }),\n *  }),\n * ```\n *\n * @param input - returned directly\n *\n * @internal\n */\nexport function typed<T>(input: T): T {\n  return input\n}\n","import type {Mutation} from '../mutations'\nimport type {CreateSquashedMutation, TransactionLogMutation} from './types'\n\n/** @internal */\nexport function isCreateSquashedMutation(\n  mutation: Mutation | TransactionLogMutation\n): mutation is CreateSquashedMutation {\n  return 'createSquashed' in mutation\n}\n","import type {FormNodeValidation} from './types'\n\n/** @internal */\nexport function isValidationError(\n  node: FormNodeValidation\n): node is FormNodeValidation & {level: 'error'} {\n  return node.level === 'error'\n}\n\n/** @internal */\nexport function isValidationWarning(\n  node: FormNodeValidation\n): node is FormNodeValidation & {level: 'warning'} {\n  return node.level === 'warning'\n}\n\n/** @internal */\nexport function isValidationInfo(\n  node: FormNodeValidation\n): node is FormNodeValidation & {level: 'info'} {\n  return node.level === 'info'\n}\n"],"names":["isObject","obj","Array","isArray","isReference","reference","_ref","isImage","value","asset","startsWith","isCrossDatasetReference","_dataset","_projectId","isSanityDocument","document","_id","_type","isTypedObject","isKeyedObject","_key","isValidationErrorMarker","marker","level","isValidationWarningMarker","isValidationInfoMarker","isCreateMutation","mutation","isCreateIfNotExistsMutation","isCreateOrReplaceMutation","isDeleteMutation","isPatchMutation","reKeySegment","reIndexTuple","isIndexSegment","segment","test","isKeySegment","trim","isIndexTuple","length","from","to","isRecord","isBlock","style","children","markDefs","isSpan","text","marks","isDocumentSchemaType","type","isObjectSchemaType","current","name","jsonType","isArraySchemaType","isArrayOfObjectsSchemaType","of","every","memberType","isArrayOfPrimitivesSchemaType","isPrimitiveSchemaType","isBooleanSchemaType","isStringSchemaType","isNumberSchemaType","isReferenceSchemaType","isCrossDatasetReferenceSchemaType","isTitledListValue","item","isSpanSchemaType","annotations","decorators","isBlockSchemaType","fields","maybeSpanChildren","maybeStyle","maybeList","isBlockChildrenObjectField","isStyleObjectField","isListObjectField","field","some","defineType","schemaDefinition","defineOptions","defineField","schemaField","defineArrayMember","arrayOfSchema","typed","input","isCreateSquashedMutation","isValidationError","node","isValidationWarning","isValidationInfo"],"mappings":"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"}