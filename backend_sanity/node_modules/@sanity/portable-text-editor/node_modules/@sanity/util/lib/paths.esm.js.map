{"version":3,"file":"paths.esm.js","sources":["../src/paths.ts"],"sourcesContent":["import {\n  IndexTuple,\n  isIndexSegment,\n  isIndexTuple,\n  isKeySegment,\n  KeyedSegment,\n  Path,\n  PathSegment,\n} from '@sanity/types'\n\nconst rePropName =\n  /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/\nconst EMPTY_PATH: Path = []\n\nexport const FOCUS_TERMINATOR = '$'\n\nexport function get<R>(obj: unknown, path: Path | string): R | undefined\nexport function get<R>(obj: unknown, path: Path | string, defaultValue: R): R\nexport function get(obj: unknown, path: Path | string, defaultVal?: unknown): unknown {\n  const select = typeof path === 'string' ? fromString(path) : path\n  if (!Array.isArray(select)) {\n    throw new Error('Path must be an array or a string')\n  }\n\n  let acc: unknown | undefined = obj\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i]\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc[segment]\n    }\n\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc.find((item) => item._key === segment._key)\n    }\n\n    if (typeof segment === 'string') {\n      acc =\n        typeof acc === 'object' && acc !== null\n          ? ((acc as Record<string, unknown>)[segment] as Record<string, unknown>)\n          : undefined\n    }\n\n    if (typeof acc === 'undefined') {\n      return defaultVal\n    }\n  }\n\n  return acc\n}\n\nconst pathsMemo = new Map<string, Path>()\nexport function pathFor(path: Path): Path {\n  if (path.length === 0) {\n    return EMPTY_PATH\n  }\n  const asString = toString(path)\n  if (pathsMemo.has(asString)) {\n    return pathsMemo.get(asString)!\n  }\n  pathsMemo.set(asString, path)\n  Object.freeze(path)\n  return path\n}\n\nexport function isEqual(path: Path, otherPath: Path): boolean {\n  return (\n    path.length === otherPath.length &&\n    path.every((segment, i) => isSegmentEqual(segment, otherPath[i]))\n  )\n}\n\nexport function numEqualSegments(path: Path, otherPath: Path): number {\n  const length = Math.min(path.length, otherPath.length)\n  for (let i = 0; i < length; i++) {\n    if (!isSegmentEqual(path[i], otherPath[i])) {\n      return i\n    }\n  }\n  return length\n}\n\nexport function isSegmentEqual(segmentA: PathSegment, segmentB: PathSegment): boolean {\n  if (isKeySegment(segmentA) && isKeySegment(segmentB)) {\n    return segmentA._key === segmentB._key\n  }\n\n  if (isIndexSegment(segmentA)) {\n    return Number(segmentA) === Number(segmentB)\n  }\n\n  if (isIndexTuple(segmentA) && isIndexTuple(segmentB)) {\n    return segmentA[0] === segmentB[0] && segmentA[1] === segmentB[1]\n  }\n\n  return segmentA === segmentB\n}\n\nexport function hasFocus(focusPath: Path, path: Path): boolean {\n  const withoutTerminator =\n    focusPath[focusPath.length - 1] === FOCUS_TERMINATOR ? focusPath.slice(0, -1) : focusPath\n  return isEqual(withoutTerminator, path)\n}\n\nexport function hasItemFocus(focusPath: Path, item: PathSegment): boolean {\n  return focusPath.length === 1 && isSegmentEqual(focusPath[0], item)\n}\n\nexport function isExpanded(segment: PathSegment, focusPath: Path): boolean {\n  const [head, ...tail] = focusPath\n  return tail.length > 0 && isSegmentEqual(segment, head)\n}\n\nexport function startsWith(prefix: Path, path: Path): boolean {\n  return prefix.every((segment, i) => isSegmentEqual(segment, path[i]))\n}\n\nexport function trimLeft(prefix: Path, path: Path): Path {\n  if (prefix.length === 0 || path.length === 0) {\n    return path\n  }\n  const [prefixHead, ...prefixTail] = prefix\n  const [pathHead, ...pathTail] = path\n  if (!isSegmentEqual(prefixHead, pathHead)) {\n    return path\n  }\n  return pathFor(trimLeft(prefixTail, pathTail))\n}\n\nexport function trimRight(suffix: Path, path: Path): Path {\n  const sufLen = suffix.length\n  const pathLen = path.length\n  if (sufLen === 0 || pathLen === 0) {\n    return path\n  }\n\n  let i = 0\n  while (\n    i < sufLen &&\n    i < pathLen &&\n    isSegmentEqual(path[pathLen - i - 1], suffix[sufLen - i - 1])\n  ) {\n    i++\n  }\n\n  return pathFor(path.slice(0, pathLen - i))\n}\n\nexport function trimChildPath(path: Path, childPath: Path): Path {\n  return startsWith(path, childPath) ? trimLeft(path, childPath) : EMPTY_PATH\n}\n\nexport function toString(path: Path): string {\n  if (!Array.isArray(path)) {\n    throw new Error('Path is not an array')\n  }\n\n  return path.reduce<string>((target, segment, i) => {\n    const segmentType = typeof segment\n    if (segmentType === 'number') {\n      return `${target}[${segment}]`\n    }\n\n    if (segmentType === 'string') {\n      const separator = i === 0 ? '' : '.'\n      return `${target}${separator}${segment}`\n    }\n\n    if (isKeySegment(segment) && segment._key) {\n      return `${target}[_key==\"${segment._key}\"]`\n    }\n\n    if (Array.isArray(segment)) {\n      const [from, to] = segment\n      return `${target}[${from}:${to}]`\n    }\n\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``)\n  }, '')\n}\n\nexport function fromString(path: string): Path {\n  if (typeof path !== 'string') {\n    throw new Error('Path is not a string')\n  }\n\n  const segments = path.match(rePropName)\n  if (!segments) {\n    throw new Error('Invalid path string')\n  }\n\n  return segments.map(normalizePathSegment)\n}\n\nfunction normalizePathSegment(segment: string): PathSegment {\n  if (isIndexSegment(segment)) {\n    return normalizeIndexSegment(segment)\n  }\n\n  if (isKeySegment(segment)) {\n    return normalizeKeySegment(segment)\n  }\n\n  if (isIndexTuple(segment)) {\n    return normalizeIndexTupleSegment(segment)\n  }\n\n  return segment\n}\n\nfunction normalizeIndexSegment(segment: string): PathSegment {\n  return Number(segment.replace(/[^\\d]/g, ''))\n}\n\nfunction normalizeKeySegment(segment: string): KeyedSegment {\n  const segments = segment.match(reKeySegment)\n  return {_key: segments![1]}\n}\n\nfunction normalizeIndexTupleSegment(segment: string): IndexTuple {\n  const [from, to] = segment.split(':').map((seg) => (seg === '' ? seg : Number(seg)))\n  return [from, to]\n}\n"],"names":["rePropName","reKeySegment","EMPTY_PATH","FOCUS_TERMINATOR","get","obj","path","defaultVal","select","fromString","Array","isArray","Error","acc","i","length","segment","isIndexSegment","isKeySegment","find","item","_key","pathsMemo","Map","pathFor","asString","toString","has","set","Object","freeze","isEqual","otherPath","every","isSegmentEqual","numEqualSegments","Math","min","segmentA","segmentB","Number","isIndexTuple","hasFocus","focusPath","withoutTerminator","slice","hasItemFocus","isExpanded","head","tail","startsWith","prefix","trimLeft","prefixHead","prefixTail","pathHead","pathTail","trimRight","suffix","sufLen","pathLen","trimChildPath","childPath","reduce","target","segmentType","separator","from","to","JSON","stringify","segments","match","map","normalizePathSegment","normalizeIndexSegment","normalizeKeySegment","normalizeIndexTupleSegment","replace","split","seg"],"mappings":";AAUA,MAAMA,UACJ,GAAA,kGAAA;AACF,MAAMC,YAAe,GAAA,0BAAA;AACrB,MAAMC,aAAmB,EAAC;AAEnB,MAAMC,gBAAmB,GAAA,GAAA;AAIhB,SAAAC,GAAA,CAAIC,GAAc,EAAAC,IAAA,EAAqBC,UAA+B,EAAA;EACpF,MAAMC,SAAS,OAAOF,IAAA,KAAS,QAAW,GAAAG,UAAA,CAAWH,IAAI,CAAI,GAAAA,IAAA;EAC7D,IAAI,CAACI,KAAA,CAAMC,OAAQ,CAAAH,MAAM,CAAG,EAAA;IACpB,MAAA,IAAII,MAAM,mCAAmC,CAAA;EACrD;EAEA,IAAIC,GAA2B,GAAAR,GAAA;EAC/B,KAAA,IAASS,CAAI,GAAA,CAAA,EAAGA,CAAI,GAAAN,MAAA,CAAOO,QAAQD,CAAK,EAAA,EAAA;IACtC,MAAME,UAAUR,MAAO,CAAAM,CAAA,CAAA;IACnB,IAAAG,cAAA,CAAeD,OAAO,CAAG,EAAA;MAC3B,IAAI,CAACN,KAAA,CAAMC,OAAQ,CAAAE,GAAG,CAAG,EAAA;QAChB,OAAAN,UAAA;MACT;MAEAM,GAAA,GAAMA,GAAI,CAAAG,OAAA,CAAA;IACZ;IAEI,IAAAE,YAAA,CAAaF,OAAO,CAAG,EAAA;MACzB,IAAI,CAACN,KAAA,CAAMC,OAAQ,CAAAE,GAAG,CAAG,EAAA;QAChB,OAAAN,UAAA;MACT;MAEAM,GAAA,GAAMA,IAAIM,IAAK,CAACC,QAASA,IAAK,CAAAC,IAAA,KAASL,QAAQK,IAAI,CAAA;IACrD;IAEI,IAAA,OAAOL,YAAY,QAAU,EAAA;MAC/BH,GAAA,GACE,OAAOA,GAAQ,KAAA,QAAA,IAAYA,GAAQ,KAAA,IAAA,GAC7BA,IAAgCG,OAClC,CAAA,GAAA,KAAA,CAAA;IACR;IAEI,IAAA,OAAOH,QAAQ,WAAa,EAAA;MACvB,OAAAN,UAAA;IACT;EACF;EAEO,OAAAM,GAAA;AACT;AAEA,MAAMS,SAAA,GAAA,mBAAgBC,GAAkB,EAAA;AACjC,SAASC,QAAQlB,IAAkB,EAAA;EACpC,IAAAA,IAAA,CAAKS,WAAW,CAAG,EAAA;IACd,OAAAb,UAAA;EACT;EACM,MAAAuB,QAAA,GAAWC,SAASpB,IAAI,CAAA;EAC1B,IAAAgB,SAAA,CAAUK,GAAI,CAAAF,QAAQ,CAAG,EAAA;IACpB,OAAAH,SAAA,CAAUlB,IAAIqB,QAAQ,CAAA;EAC/B;EACUH,SAAA,CAAAM,GAAA,CAAIH,UAAUnB,IAAI,CAAA;EAC5BuB,MAAA,CAAOC,OAAOxB,IAAI,CAAA;EACX,OAAAA,IAAA;AACT;AAEgB,SAAAyB,OAAA,CAAQzB,MAAY0B,SAA0B,EAAA;EAC5D,OACE1B,IAAK,CAAAS,MAAA,KAAWiB,SAAU,CAAAjB,MAAA,IAC1BT,IAAK,CAAA2B,KAAA,CAAM,CAACjB,OAAA,EAASF,CAAM,KAAAoB,cAAA,CAAelB,OAAS,EAAAgB,SAAA,CAAUlB,EAAE,CAAC,CAAA;AAEpE;AAEgB,SAAAqB,gBAAA,CAAiB7B,MAAY0B,SAAyB,EAAA;EACpE,MAAMjB,SAASqB,IAAK,CAAAC,GAAA,CAAI/B,IAAK,CAAAS,MAAA,EAAQiB,UAAUjB,MAAM,CAAA;EACrD,KAAA,IAASD,CAAI,GAAA,CAAA,EAAGA,CAAI,GAAAC,MAAA,EAAQD,CAAK,EAAA,EAAA;IAC/B,IAAI,CAACoB,cAAe,CAAA5B,IAAA,CAAKQ,CAAI,CAAA,EAAAkB,SAAA,CAAUlB,EAAE,CAAG,EAAA;MACnC,OAAAA,CAAA;IACT;EACF;EACO,OAAAC,MAAA;AACT;AAEgB,SAAAmB,cAAA,CAAeI,UAAuBC,QAAgC,EAAA;EACpF,IAAIrB,YAAa,CAAAoB,QAAQ,CAAK,IAAApB,YAAA,CAAaqB,QAAQ,CAAG,EAAA;IAC7C,OAAAD,QAAA,CAASjB,SAASkB,QAAS,CAAAlB,IAAA;EACpC;EAEI,IAAAJ,cAAA,CAAeqB,QAAQ,CAAG,EAAA;IAC5B,OAAOE,MAAO,CAAAF,QAAQ,CAAM,KAAAE,MAAA,CAAOD,QAAQ,CAAA;EAC7C;EAEA,IAAIE,YAAa,CAAAH,QAAQ,CAAK,IAAAG,YAAA,CAAaF,QAAQ,CAAG,EAAA;IACpD,OAAOD,SAAS,CAAO,CAAA,KAAAC,QAAA,CAAS,CAAM,CAAA,IAAAD,QAAA,CAAS,OAAOC,QAAS,CAAA,CAAA,CAAA;EACjE;EAEA,OAAOD,QAAa,KAAAC,QAAA;AACtB;AAEgB,SAAAG,QAAA,CAASC,WAAiBrC,IAAqB,EAAA;EACvD,MAAAsC,iBAAA,GACJD,SAAU,CAAAA,SAAA,CAAU5B,MAAS,GAAA,CAAA,CAAA,KAAOZ,mBAAmBwC,SAAU,CAAAE,KAAA,CAAM,CAAG,EAAA,CAAA,CAAE,CAAI,GAAAF,SAAA;EAC3E,OAAAZ,OAAA,CAAQa,mBAAmBtC,IAAI,CAAA;AACxC;AAEgB,SAAAwC,YAAA,CAAaH,WAAiBvB,IAA4B,EAAA;EACxE,OAAOuB,UAAU5B,MAAW,KAAA,CAAA,IAAKmB,cAAe,CAAAS,SAAA,CAAU,IAAIvB,IAAI,CAAA;AACpE;AAEgB,SAAA2B,UAAA,CAAW/B,SAAsB2B,SAA0B,EAAA;EACnE,MAAA,CAACK,IAAS,EAAA,GAAAC,IAAI,CAAI,GAAAN,SAAA;EACxB,OAAOM,IAAK,CAAAlC,MAAA,GAAS,CAAK,IAAAmB,cAAA,CAAelB,SAASgC,IAAI,CAAA;AACxD;AAEgB,SAAAE,UAAA,CAAWC,QAAc7C,IAAqB,EAAA;EACrD,OAAA6C,MAAA,CAAOlB,MAAM,CAACjB,OAAA,EAASF,MAAMoB,cAAe,CAAAlB,OAAA,EAASV,IAAK,CAAAQ,CAAA,CAAE,CAAC,CAAA;AACtE;AAEgB,SAAAsC,QAAA,CAASD,QAAc7C,IAAkB,EAAA;EACvD,IAAI6C,MAAO,CAAApC,MAAA,KAAW,CAAK,IAAAT,IAAA,CAAKS,WAAW,CAAG,EAAA;IACrC,OAAAT,IAAA;EACT;EACM,MAAA,CAAC+C,UAAe,EAAA,GAAAC,UAAU,CAAI,GAAAH,MAAA;EAC9B,MAAA,CAACI,QAAa,EAAA,GAAAC,QAAQ,CAAI,GAAAlD,IAAA;EAChC,IAAI,CAAC4B,cAAA,CAAemB,UAAY,EAAAE,QAAQ,CAAG,EAAA;IAClC,OAAAjD,IAAA;EACT;EACA,OAAOkB,OAAQ,CAAA4B,QAAA,CAASE,UAAY,EAAAE,QAAQ,CAAC,CAAA;AAC/C;AAEgB,SAAAC,SAAA,CAAUC,QAAcpD,IAAkB,EAAA;EACxD,MAAMqD,SAASD,MAAO,CAAA3C,MAAA;EACtB,MAAM6C,UAAUtD,IAAK,CAAAS,MAAA;EACjB,IAAA4C,MAAA,KAAW,CAAK,IAAAC,OAAA,KAAY,CAAG,EAAA;IAC1B,OAAAtD,IAAA;EACT;EAEA,IAAIQ,CAAI,GAAA,CAAA;EACR,OACEA,CAAI,GAAA6C,MAAA,IACJ7C,CAAI,GAAA8C,OAAA,IACJ1B,cAAe,CAAA5B,IAAA,CAAKsD,OAAU,GAAA9C,CAAA,GAAI,CAAI,CAAA,EAAA4C,MAAA,CAAOC,MAAS,GAAA7C,CAAA,GAAI,EAAE,CAC5D,EAAA;IACAA,CAAA,EAAA;EACF;EAEA,OAAOU,QAAQlB,IAAK,CAAAuC,KAAA,CAAM,CAAG,EAAAe,OAAA,GAAU9C,CAAC,CAAC,CAAA;AAC3C;AAEgB,SAAA+C,aAAA,CAAcvD,MAAYwD,SAAuB,EAAA;EAC/D,OAAOZ,WAAW5C,IAAM,EAAAwD,SAAS,IAAIV,QAAS,CAAA9C,IAAA,EAAMwD,SAAS,CAAI,GAAA5D,UAAA;AACnE;AAEO,SAASwB,SAASpB,IAAoB,EAAA;EAC3C,IAAI,CAACI,KAAA,CAAMC,OAAQ,CAAAL,IAAI,CAAG,EAAA;IAClB,MAAA,IAAIM,MAAM,sBAAsB,CAAA;EACxC;EAEA,OAAON,IAAK,CAAAyD,MAAA,CAAe,CAACC,MAAA,EAAQhD,SAASF,CAAM,KAAA;IACjD,MAAMmD,cAAc,OAAOjD,OAAA;IAC3B,IAAIiD,gBAAgB,QAAU,EAAA;MAC5B,iBAAUD,MAAU,cAAAhD,OAAA;IACtB;IAEA,IAAIiD,gBAAgB,QAAU,EAAA;MACtB,MAAAC,SAAA,GAAYpD,CAAM,KAAA,CAAA,GAAI,EAAK,GAAA,GAAA;MAC1B,iBAAGkD,eAASE,SAAY,SAAAlD,OAAA;IACjC;IAEA,IAAIE,YAAa,CAAAF,OAAO,CAAK,IAAAA,OAAA,CAAQK,IAAM,EAAA;MAClC,iBAAG2C,4BAAiBhD,OAAQ,CAAAK,IAAA;IACrC;IAEI,IAAAX,KAAA,CAAMC,OAAQ,CAAAK,OAAO,CAAG,EAAA;MACpB,MAAA,CAACmD,IAAM,EAAAC,EAAE,CAAI,GAAApD,OAAA;MACZ,iBAAGgD,oBAAUG,IAAQ,cAAAC,EAAA;IAC9B;IAEA,MAAM,IAAIxD,KAAM,qCAA8ByD,IAAK,CAAAC,SAAA,CAAUtD,OAAO,CAAK,OAAA;KACxE,EAAE,CAAA;AACP;AAEO,SAASP,WAAWH,IAAoB,EAAA;EACzC,IAAA,OAAOA,SAAS,QAAU,EAAA;IACtB,MAAA,IAAIM,MAAM,sBAAsB,CAAA;EACxC;EAEM,MAAA2D,QAAA,GAAWjE,IAAK,CAAAkE,KAAA,CAAMxE,UAAU,CAAA;EACtC,IAAI,CAACuE,QAAU,EAAA;IACP,MAAA,IAAI3D,MAAM,qBAAqB,CAAA;EACvC;EAEO,OAAA2D,QAAA,CAASE,IAAIC,oBAAoB,CAAA;AAC1C;AAEA,SAASA,qBAAqB1D,OAA8B,EAAA;EACtD,IAAAC,cAAA,CAAeD,OAAO,CAAG,EAAA;IAC3B,OAAO2D,sBAAsB3D,OAAO,CAAA;EACtC;EAEI,IAAAE,YAAA,CAAaF,OAAO,CAAG,EAAA;IACzB,OAAO4D,oBAAoB5D,OAAO,CAAA;EACpC;EAEI,IAAAyB,YAAA,CAAazB,OAAO,CAAG,EAAA;IACzB,OAAO6D,2BAA2B7D,OAAO,CAAA;EAC3C;EAEO,OAAAA,OAAA;AACT;AAEA,SAAS2D,sBAAsB3D,OAA8B,EAAA;EAC3D,OAAOwB,MAAO,CAAAxB,OAAA,CAAQ8D,OAAQ,CAAA,QAAA,EAAU,EAAE,CAAC,CAAA;AAC7C;AAEA,SAASF,oBAAoB5D,OAA+B,EAAA;EACpD,MAAAuD,QAAA,GAAWvD,OAAQ,CAAAwD,KAAA,CAAMvE,YAAY,CAAA;EACpC,OAAA;IAACoB,IAAM,EAAAkD,QAAA,CAAU,CAAE;EAAA,CAAA;AAC5B;AAEA,SAASM,2BAA2B7D,OAA6B,EAAA;EAC/D,MAAM,CAACmD,IAAM,EAAAC,EAAE,CAAI,GAAApD,OAAA,CAAQ+D,MAAM,GAAG,CAAA,CAAEN,GAAI,CAACO,OAASA,GAAQ,KAAA,EAAA,GAAKA,GAAM,GAAAxC,MAAA,CAAOwC,GAAG,CAAE,CAAA;EAC5E,OAAA,CAACb,MAAMC,EAAE,CAAA;AAClB;"}