"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useScrollToFocusFromOutside = useScrollToFocusFromOutside;
var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));
var _portableTextEditor = require("@sanity/portable-text-editor");
var _react = require("react");
var _scrollIntoViewIfNeeded = _interopRequireDefault(require("scroll-into-view-if-needed"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
// This hook will scroll related editor item into view when the focusPath is pointing to a embedded object.
function useScrollToFocusFromOutside(hasFocus, focusPath, objectEditData, scrollElement) {
  var objectEditorPathRef = (0, _react.useRef)(null);
  var focusPathRef = (0, _react.useRef)(null);
  var editor = (0, _portableTextEditor.usePortableTextEditor)();

  // This will scroll to the relevant block with focusPath pointing to an embedded object inside.
  (0, _react.useEffect)(() => {
    if (!hasFocus && objectEditData && objectEditData.editorHTMLElementRef.current && objectEditorPathRef.current !== objectEditData.editorPath) {
      (0, _scrollIntoViewIfNeeded.default)(objectEditData.editorHTMLElementRef.current, {
        boundary: scrollElement,
        scrollMode: 'if-needed'
      });
      var point = {
        path: focusPath,
        offset: 0
      };
      var selection = {
        anchor: point,
        focus: point
      };
      if (!_portableTextEditor.PortableTextEditor.isObjectPath(editor, focusPath)) {
        _portableTextEditor.PortableTextEditor.select(editor, selection);
      }
      objectEditorPathRef.current = objectEditData.editorPath;
    }
  }, [editor, focusPath, hasFocus, objectEditData, scrollElement]);

  // This will scroll to the relevant text block if the focus path directly on a regular text block.
  (0, _react.useEffect)(() => {
    var _PortableTextEditor$g;
    if (!hasFocus && objectEditData === null && focusPath.length === 1 &&
    // Only if single block
    !(0, _isEqual2.default)(focusPath, (_PortableTextEditor$g = _portableTextEditor.PortableTextEditor.getSelection(editor)) === null || _PortableTextEditor$g === void 0 ? void 0 : _PortableTextEditor$g.focus.path) && !_portableTextEditor.PortableTextEditor.isObjectPath(editor, focusPath)) {
      var _PortableTextEditor$f = _portableTextEditor.PortableTextEditor.findByPath(editor, focusPath),
        _PortableTextEditor$f2 = _slicedToArray(_PortableTextEditor$f, 1),
        block = _PortableTextEditor$f2[0];
      var blockElm = _portableTextEditor.PortableTextEditor.findDOMNode(editor, block);
      if (blockElm) {
        (0, _scrollIntoViewIfNeeded.default)(blockElm, {
          boundary: scrollElement,
          scrollMode: 'if-needed'
        });
        var point = {
          path: focusPath,
          offset: 0
        };
        var selection = {
          anchor: point,
          focus: point
        };
        _portableTextEditor.PortableTextEditor.select(editor, selection);
        _portableTextEditor.PortableTextEditor.focus(editor);
      }
    }
    focusPathRef.current = focusPath;
  }, [editor, focusPath, hasFocus, objectEditData, scrollElement]);
}