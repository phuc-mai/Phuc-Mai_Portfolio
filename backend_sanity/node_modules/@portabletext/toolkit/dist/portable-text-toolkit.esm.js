function e(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function t(t){for(var r=1;r<arguments.length;r++){var i=null!=arguments[r]?arguments[r]:{};r%2?e(Object(i),!0).forEach((function(e){n(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):e(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}function n(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e){return"span"===e._type&&"text"in e&&"string"==typeof e.text&&(void 0===e.marks||Array.isArray(e.marks)&&e.marks.every((e=>"string"==typeof e)))}function i(e){return"string"==typeof e._type&&"@"!==e._type[0]&&(!("markDefs"in e)||Array.isArray(e.markDefs)&&e.markDefs.every((e=>"string"==typeof e._key)))&&"children"in e&&Array.isArray(e.children)&&e.children.every((e=>"object"==typeof e&&"_type"in e))}function l(e){return i(e)&&"listItem"in e&&"string"==typeof e.listItem&&(void 0===e.level||"number"==typeof e.level)}function c(e){return"@list"===e._type}function o(e){return"@span"===e._type}function s(e){return"@text"===e._type}const f=["strong","em","code","underline","strike-through"];function u(e,t,n){if(!r(e)||!e.marks)return[];if(!e.marks.length)return[];const i=e.marks.slice(),l={};return i.forEach((e=>{l[e]=1;for(let i=t+1;i<n.length;i++){const t=n[i];if(!(t&&r(t)&&Array.isArray(t.marks)&&-1!==t.marks.indexOf(e)))break;l[e]++}})),i.sort(((e,t)=>function(e,t,n){const r=e[t],i=e[n];if(r!==i)return i-r;const l=f.indexOf(t),c=f.indexOf(n);if(l!==c)return l-c;return t.localeCompare(n)}(l,e,t)))}function h(e){var t;const{children:n,markDefs:i=[]}=e;if(!n||!n.length)return[];const l=n.map(u),c={_type:"@span",children:[],markType:"<unknown>"};let o=[c];for(let e=0;e<n.length;e++){const c=n[e];if(!c)continue;const s=l[e]||[];let f=1;if(o.length>1)for(;f<o.length;f++){const e=(null==(t=o[f])?void 0:t.markKey)||"",n=s.indexOf(e);if(-1===n)break;s.splice(n,1)}o=o.slice(0,f);let u=o[o.length-1];if(u){for(const e of s){const t=i.find((t=>t._key===e)),n=t?t._type:e,r={_type:"@span",_key:c._key,children:[],markDef:t,markType:n,markKey:e};u.children.push(r),o.push(r),u=r}if(r(c)){const e=c.text.split("\n");for(let t=e.length;t-- >1;)e.splice(t,0,"\n");u.children=u.children.concat(e.map((e=>({_type:"@text",text:e}))))}else u.children=u.children.concat(c)}}return c.children}function a(e,n){const r=[];let i;for(let c=0;c<e.length;c++){const o=e[c];if(o)if(l(o))if(i)if(p(o,i))i.children.push(o);else if((o.level||1)>i.level){const e=y(o,c,n);if("html"===n){const n=i.children[i.children.length-1],r=t(t({},n),{},{children:[...n.children,e]});i.children[i.children.length-1]=r}else i.children.push(e);i=e}else if((o.level||1)<i.level){const e=r[r.length-1],t=e&&d(e,o);if(t){i=t,i.children.push(o);continue}i=y(o,c,n),r.push(i)}else if(o.listItem===i.listItem)console.warn("Unknown state encountered for block",o),r.push(o);else{const e=r[r.length-1],t=e&&d(e,{level:o.level||1});if(t&&t.listItem===o.listItem){i=t,i.children.push(o);continue}i=y(o,c,n),r.push(i)}else i=y(o,c,n),r.push(i);else r.push(o),i=void 0}return r}function p(e,t){return(e.level||1)===t.level&&e.listItem===t.listItem}function y(e,t,n){return{_type:"@list",_key:"".concat(e._key||"".concat(t),"-parent"),mode:n,level:e.level||1,listItem:e.listItem,children:[e]}}function d(e,t){const n=t.level||1,i=t.listItem||"normal",l="string"==typeof t.listItem;if(c(e)&&(e.level||1)===n&&l&&(e.listItem||"normal")===i)return e;if(!("children"in e))return;const o=e.children[e.children.length-1];return o&&!r(o)?d(o,t):void 0}const m=/^\s/,g=/^\s/;function k(e){const t=Array.isArray(e)?e:[e];let n="";return t.forEach(((e,l)=>{if(!i(e))return;let c=!1;e.children.forEach((e=>{r(e)?(n+=c&&n&&!g.test(n)&&!m.test(e.text)?" ":"",n+=e.text,c=!1):c=!0})),l!==t.length-1&&(n+="\n\n")})),n}function v(e){let t="";return e.children.forEach((e=>{s(e)?t+=e.text:o(e)&&(t+=v(e))})),t}const b="html",O="direct";export{O as LIST_NEST_MODE_DIRECT,b as LIST_NEST_MODE_HTML,h as buildMarksTree,i as isPortableTextBlock,l as isPortableTextListItemBlock,r as isPortableTextSpan,c as isPortableTextToolkitList,o as isPortableTextToolkitSpan,s as isPortableTextToolkitTextNode,a as nestLists,u as sortMarksByOccurences,v as spanToPlainText,k as toPlainText};
//# sourceMappingURL=portable-text-toolkit.esm.js.map
